<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Jose Storopoli" />
  <meta name="author" content="Rik Huijzer" />
  <meta name="author" content="Lazaro Alonso" />
  <title>GLMakie.jl - Julia Data Science</title>
  <link rel="shortcut icon" type="image/png" href="/JuliaDataScience/favicon.png"/>
  <link rel="stylesheet" href="/JuliaDataScience/style.css"/>
    <script src="/JuliaDataScience/mousetrap.min.js"></script>
    <style>
  @font-face {
    font-family: JuliaMono-Regular;
    src: url("/JuliaDataScience/JuliaMono-Regular.woff2");
  }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <link rel="stylesheet" href="/JuliaDataScience/github.min.css">
<script src="/JuliaDataScience/highlight.min.js"></script>
<script src="/JuliaDataScience/julia.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', (event) => {
    document.querySelectorAll('pre').forEach((el) => {
        if (!el.classList.contains('output')) {
            hljs.highlightElement(el);
        }
    });
});
</script>
 
</head>
<body>
<script>
function click_next() {
  var next = document.getElementById('nav-next');
  next.firstElementChild.nextElementSibling.click();
}
function click_prev() {
  var prev = document.getElementById('nav-prev');
  prev.firstElementChild.click();
}
Mousetrap.bind('right', click_next);
Mousetrap.bind('h', click_prev);
Mousetrap.bind('left', click_prev);
Mousetrap.bind('l', click_next);
</script>

<div class="books-container">
<aside class="books-menu">
<input type="checkbox" id="menu">
<label for="menu">☰</label>
<div class="books-title">
<a href="/JuliaDataScience/">Julia Data Science</a>
</div><br />
<span class="books-subtitle">

</span>
<div class="books-menu-content">
<li><a class="menu-level-1" href="/JuliaDataScience/preface"><b>1</b> Preface</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/why_data_science"><b>1.1</b> What is Data Science?</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/engineering"><b>1.2</b> Software Engineering</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/acknowledgements"><b>1.3</b> Acknowledgements</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/why_julia"><b>2</b> Why Julia?</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/non-programmers"><b>2.1</b> For Non-Programmers</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/programmers"><b>2.2</b> For Programmers</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/julia_accomplish"><b>2.3</b> What Julia Aims to Accom..</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/julia_wild"><b>2.4</b> Julia in the Wild</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/julia_basics"><b>3</b> Julia Basics</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/ide"><b>3.1</b> Development Environments</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/syntax"><b>3.2</b> Language Syntax</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/data_structures"><b>3.3</b> Native Data Structures</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/filesystem"><b>3.4</b> Filesystem</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/standardlibrary"><b>3.5</b> Julia Standard Library</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/dataframes"><b>4</b> DataFrames.jl</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/load_save"><b>4.1</b> Load and Save Files</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/index-and-summarize"><b>4.2</b> Index and Summarize</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/filter_subset"><b>4.3</b> Filter and Subset</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/select"><b>4.4</b> Select</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/types"><b>4.5</b> Types and Categorical Da..</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/join"><b>4.6</b> Join</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/transform"><b>4.7</b> Variable Transformations</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/groupby_combine"><b>4.8</b> Groupby and Combine</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/missing"><b>4.9</b> Missing Data</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/df_performance"><b>4.10</b> Performance</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/dataframesmeta"><b>5</b> DataFramesMeta.jl</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/dataframesmeta_macros"><b>5.1</b> Macros</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/dataframesmeta_select"><b>5.2</b> Column Selection</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/dataframesmeta_transform"><b>5.3</b> Column Transformation</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/dataframesmeta_subset"><b>5.4</b> Row Selection</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/dataframesmeta_orderby"><b>5.5</b> Row Sorting</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/dataframesmeta_combine"><b>5.6</b> Data Summaries</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/dataframesmeta_chain"><b>5.7</b> Piping Operations</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/DataVisualizationMakie"><b>6</b> Data Visualization with Ma..</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/cairomakie"><b>6.1</b> CairoMakie.jl</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/datavisMakie_attributes"><b>6.2</b> Attributes</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/datavisMakie_create_Figure"><b>6.3</b> Create Plot Figure</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/makie_cheat_sheets"><b>6.4</b> Cheat Sheets</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/themes"><b>6.5</b> Themes</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/using-latexstrings.jl"><b>6.6</b> Using LaTeXStrings.jl</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/makie_colors"><b>6.7</b> Colors and Colormaps</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/makie_layouts"><b>6.8</b> Layouts</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/glmakie"><b>6.9</b> GLMakie.jl</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/recipe_df"><b>6.10</b> A Makie recipe for a Da..</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/aog"><b>7</b> Data Visualization with Al..</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/aog_layers"><b>7.1</b> Layers</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/aog_layouts"><b>7.2</b> Layouts</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/aog_stats"><b>7.3</b> Statistical Visualizatio..</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/aog_custom"><b>7.4</b> Plot Customizations</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/aog_makie"><b>7.5</b> Makie.jl and AlgebraOfGr..</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/appendix"><b>8</b> Appendix</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/appendix_pkg"><b>8.1</b> Packages Versions</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/notation"><b>8.2</b> Notation</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/references"><b></b> References</a></li>
</div>
</aside>

<div class="books-content">
<h2 data-number="6.9" id="sec:glmakie"><span class="header-section-number">6.9</span> GLMakie.jl</h2>
<p><code>CairoMakie.jl</code> fulfills all our needs for static 2D images. But sometimes we want interactivity, especially when we are dealing with 3D images. Visualizing data in 3D is also a common practice to gain insight from your data. This is where <code>GLMakie.jl</code> comes into play, since it uses <a href="http://www.opengl.org/">OpenGL</a> as a backend that adds interactivity and responsiveness to plots. Like before, a simple plot includes, of course, lines and points. So, we will start with those and since we already know how layouts work, we will put that into practice.</p>
<h3 data-number="6.9.1" id="scatters-and-lines"><span class="header-section-number">6.9.1</span> Scatters and Lines</h3>
<p>For scatter plots we have two options, the first one is <code>scatter(x, y, z)</code> and the second one is <code>meshscatter(x, y, z)</code>. In the former, markers don’t scale in the axis directions and in the latter they do because they are actual geometries in 3D space. See the next example:</p>
<pre><code>using GLMakie
GLMakie.activate!()</code></pre>
<pre class="language-julia"><code>function scatters_in_3D()
    seed!(123)
    n = 10
    x, y, z = randn(n), randn(n), randn(n)
    aspect=(1, 1, 1)
    perspectiveness=0.5
    # the figure
    fig = Figure(; size=(1200, 400))
    ax1 = Axis3(fig[1, 1]; aspect, perspectiveness)
    ax2 = Axis3(fig[1, 2]; aspect, perspectiveness)
    ax3 = Axis3(fig[1, 3]; aspect=:data, perspectiveness)
    scatter!(ax1, x, y, z; markersize=15)
    meshscatter!(ax2, x, y, z; markersize=0.25)
    hm = meshscatter!(ax3, x, y, z; markersize=0.25,
        marker=Rect3f(Vec3f(0), Vec3f(1)), color=1:n,
        colormap=:plasma, transparency=false)
    Colorbar(fig[1, 4], hm, label=&quot;values&quot;, height=Relative(0.5))
    colgap!(fig.layout, 5)
    fig
end
JDS.scatters_in_3D()</code></pre>
<figure id="fig:scatters_in_3D">
<img src="/JuliaDataScience/im/JDS_scatters_in_3D_.png" alt="Figure 34: Scatters in 3D." />
<figcaption aria-hidden="true">Figure 34: Scatters in 3D.</figcaption>
</figure>
<p>Note also, that a different geometry can be passed as markers, i.e., a square/rectangle, and we can assign a <code>colormap</code> for them as well. In the middle panel one could get perfect spheres by doing <code>aspect = :data</code> as in the right panel.</p>
<p>And doing <code>lines</code> or <code>scatterlines</code> is also straightforward:</p>
<pre class="language-julia"><code>function lines_in_3D()
    seed!(123)
    n = 10
    x, y, z = randn(n), randn(n), randn(n)
    aspect=(1, 1, 1)
    perspectiveness=0.5
    # the figure
    fig = Figure(; size=(1200, 500))
    ax1 = Axis3(fig[1, 1]; aspect, perspectiveness)
    ax2 = Axis3(fig[1, 2]; aspect, perspectiveness)
    ax3 = Axis3(fig[1, 3]; aspect=:data, perspectiveness)
    lines!(ax1, x, y, z; color=1:n, linewidth=3)
    scatterlines!(ax2, x, y, z; markersize=15)
    hm = meshscatter!(ax3, x, y, z; markersize=0.2, color=1:n)
    lines!(ax3, x, y, z; color=1:n)
    Colorbar(fig[2, 1], hm; label=&quot;values&quot;, height=15, vertical=false,
        flipaxis=false, ticksize=15, tickalign=1, width=Relative(3.55/4))
    fig
end

# written by Josef Heinen from GR.jl
JDS.lines_in_3D()</code></pre>
<figure id="fig:lines_in_3D">
<img src="/JuliaDataScience/im/JDS_lines_in_3D_.png" alt="Figure 35: Lines in 3D." />
<figcaption aria-hidden="true">Figure 35: Lines in 3D.</figcaption>
</figure>
<p>Plotting a <code>surface</code> is also easy to do as well as a <code>wireframe</code> and <code>contour</code> lines in 3D.</p>
<h3 data-number="6.9.2" id="surfaces-wireframe-contour-contourf-and-contour3d"><span class="header-section-number">6.9.2</span> Surfaces, wireframe, contour, contourf and contour3d</h3>
<p>To show these cases we’ll use the following <code>peaks</code> function:</p>
<pre class="language-julia"><code>function peaks(; n=49)
    x = range(-3, 3, n)
    y = range(-3, 3, n)
    a = 3 * (1 .- x&#39;) .^ 2 .* exp.(-(x&#39; .^ 2) .- (y .+ 1) .^ 2)
    b = 10 * (x&#39; / 5 .- x&#39; .^ 3 .- y .^ 5) .* exp.(-x&#39; .^ 2 .- y .^ 2)
    c = 1 / 3 * exp.(-(x&#39; .+ 1) .^ 2 .- y .^ 2)
    return (x, y, a .- b .- c)
end</code></pre>
<p>The output for the different plotting functions is</p>
<pre class="language-julia"><code>function plot_peaks_function()
    x, y, z = peaks()
    x2, y2, z2 = peaks(; n=15)
    fig = Figure(size=(1200, 400))
    axs = [Axis3(fig[1, i]; aspect=(1, 1, 1)) for i = 1:3]
    hm = surface!(axs[1], x, y, z)
    wireframe!(axs[2], x2, y2, z2)
    contour3d!(axs[3], x, y, z; levels=20)
    Colorbar(fig[1, 4], hm, height=Relative(0.5))
    fig
end
JDS.plot_peaks_function()</code></pre>
<figure id="fig:plot_peaks_function">
<img src="/JuliaDataScience/im/JDS_plot_peaks_function_.png" alt="Figure 36: Plot peaks function." />
<figcaption aria-hidden="true">Figure 36: Plot peaks function.</figcaption>
</figure>
<p>But, it can also be plotted with a <code>heatmap(x, y, z)</code>, <code>contour(x, y, z)</code> or <code>contourf(x, y, z)</code>:</p>
<pre class="language-julia"><code>function heatmap_contour_and_contourf()
    x, y, z = peaks()
    fig = Figure(size=(1200, 400))
    axs = [Axis(fig[1, i]; aspect=DataAspect()) for i = 1:3]
    hm = heatmap!(axs[1], x, y, z)
    contour!(axs[2], x, y, z; levels=20)
    contourf!(axs[3], x, y, z)
    Colorbar(fig[1, 4], hm, height=Relative(0.5))
    fig
end
JDS.heatmap_contour_and_contourf()</code></pre>
<figure id="fig:heatmap_contour_and_contourf">
<img src="/JuliaDataScience/im/JDS_heatmap_contour_and_contourf_.png" alt="Figure 37: Heatmap contour and contourf." />
<figcaption aria-hidden="true">Figure 37: Heatmap contour and contourf.</figcaption>
</figure>
<p>Additionally, by changing <code>Axis</code> to an <code>Axis3</code>, these plots will be automatically be in the x-y plane at <code>z=0</code>:</p>
<pre class="language-julia"><code>function heatmap_contour_and_contourf_in_a_3d_plane()
    x, y, z = peaks()
    fig = Figure(size=(1200, 400))
    axs = [Axis3(fig[1, i]) for i = 1:3]
    hm = heatmap!(axs[1], x, y, z)
    contour!(axs[2], x, y, z; levels=20)
    contourf!(axs[3], x, y, z)
    Colorbar(fig[1, 4], hm, height=Relative(0.5))
    fig
end
JDS.heatmap_contour_and_contourf_in_a_3d_plane()</code></pre>
<figure id="fig:heatmap_contour_and_contourf_in_a_3d_plane">
<img src="/JuliaDataScience/im/JDS_heatmap_contour_and_contourf_in_a_3d_plane_.png" alt="Figure 38: Heatmap contour and contourf in a 3d plane." />
<figcaption aria-hidden="true">Figure 38: Heatmap contour and contourf in a 3d plane.</figcaption>
</figure>
<p>Something else that is easy to do is to mix all these plotting functions into just one plot, namely:</p>
<pre><code>using TestImages</code></pre>
<pre class="language-julia"><code>function mixing_surface_contour3d_contour_and_contourf()
    img = testimage(&quot;coffee.png&quot;)
    x, y, z = peaks()
    cmap = :Spectral_11
    fig = Figure(size=(1200, 800), fontsize=26)
    ax1 = Axis3(fig[1, 1]; aspect=(1, 1, 1),
        elevation=π/6, perspectiveness=0.5,
        xzpanelcolor=(:black, 0.75), yzpanelcolor=:black,
        zgridcolor=:grey70, ygridcolor=:grey70, xgridcolor=:grey70)
    ax2 = Axis3(fig[1, 3]; aspect=(1, 1, 1),
        elevation=π/6, perspectiveness=0.5)
    hm = surface!(ax1, x, y, z; colormap=(cmap, 0.95), shading=true)
    contour3d!(ax1, x, y, z .+ 0.02; colormap=cmap, levels=20, linewidth=2)
    # get final limits
    xmin, ymin, zmin = minimum(ax1.finallimits[])
    xmax, ymax, zmax = maximum(ax1.finallimits[])
    contour!(ax1, x, y, z; colormap=cmap, levels=20,
        transformation=(:xy, zmax))
    contourf!(ax1, x, y, z; colormap=cmap,
        transformation=(:xy, zmin))
    Colorbar(fig[1, 2], hm, width=15, ticksize=15, tickalign=1,
        height=Relative(0.35))
    # transformations into planes
    heatmap!(ax2, x, y, z; colormap=:viridis,
        transformation=(:yz, 3.5))
    contourf!(ax2, x, y, z; colormap=:CMRmap,
        transformation=(:xy, -3.5))
    contourf!(ax2, x, y, z; colormap=:bone_1,
        transformation=(:xz, 3.5))
    image!(ax2, -3 .. 3, -3 .. 2, rotr90(img);
        transformation=(:xy, 3.8))
    xlims!(ax2, -3.8, 3.8)
    ylims!(ax2, -3.8, 3.8)
    zlims!(ax2, -3.8, 3.8)
    fig
end
JDS.mixing_surface_contour3d_contour_and_contourf()</code></pre>
<figure id="fig:mixing_surface_contour3d_contour_and_contourf">
<img src="/JuliaDataScience/im/JDS_mixing_surface_contour3d_contour_and_contourf_.png" style="width:60.0%" alt="Figure 39: Mixing surface, contour3d, contour and contourf." />
<figcaption aria-hidden="true">Figure 39: Mixing surface, contour3d, contour and contourf.</figcaption>
</figure>
<p>Not bad, right? From there is clear that any <code>heatmap</code>’s, <code>contour</code>’s, <code>contourf</code>’s or <code>image</code> can be plotted into any plane via a <code>transformation</code> and that the <code>planes</code> can be coloured, i.e. <code>xzpanelcolor=:black</code>.</p>
<h3 data-number="6.9.3" id="arrows-and-streamplots"><span class="header-section-number">6.9.3</span> Arrows and Streamplots</h3>
<p><code>arrows2d</code>/<code>arrows3d</code> and <code>streamplot</code> are plots that might be useful when we want to know the directions that a given variable will follow. See a demonstration below<a href="/JuliaDataScience#fn18" class="footnote-ref" id="fnref18" role="doc-noteref"><sup>18</sup></a>:</p>
<pre><code>using LinearAlgebra</code></pre>
<pre class="language-julia"><code>function arrows_and_streamplot_in_3d()
    ps = [Point3f(x, y, z) for x=-3:1:3 for y=-3:1:3 for z=-3:1:3]
    ns = map(p -&gt; 0.1 * rand() * Vec3f(p[2], p[3], p[1]), ps)
    lengths = norm.(ns)
    flowField(x, y, z) = Point(-y + x * (-1 + x^2 + y^2)^2,
        x + y * (-1 + x^2 + y^2)^2, z + x * (y - z^2))
    fig = Figure(size=(1200, 800), fontsize=26)
    axs = [Axis3(fig[1, i]; aspect=(1,1,1), perspectiveness=0.5) for i=1:2]
    arrows3d!(axs[1], ps, ns, color=lengths, tiplength=0.25)
    streamplot!(axs[2], flowField, -4 .. 4, -4 .. 4, -4 .. 4,
        colormap=:plasma, gridsize=(7, 7), arrow_size=0.25, linewidth=1)
    fig
end
JDS.arrows_and_streamplot_in_3d()</code></pre>
<figure id="fig:arrows_and_streamplot_in_3d">
<img src="/JuliaDataScience/im/JDS_arrows_and_streamplot_in_3d_.png" style="width:60.0%" alt="Figure 40: Arrows and streamplot in 3d." />
<figcaption aria-hidden="true">Figure 40: Arrows and streamplot in 3d.</figcaption>
</figure>
<p>Other interesting examples are a <code>mesh(obj)</code>, a <code>volume(x, y, z, vals)</code>, and a <code>contour(x, y, z, vals)</code>.</p>
<h3 data-number="6.9.4" id="meshes-and-volumes"><span class="header-section-number">6.9.4</span> Meshes and Volumes</h3>
<p>Drawing meshes comes in handy when you want to plot geometries, like a <code>Sphere</code> or a Rectangle, i.e. <code>FRect3D</code>. Another approach to visualize points in 3D space is by calling the functions <code>volume</code> and <code>contour</code>, which implements <a href="https://en.wikipedia.org/wiki/Ray_tracing_(graphics)">ray tracing</a> to simulate a wide variety of optical effects. See the next examples:</p>
<pre><code>using GeometryBasics</code></pre>
<pre class="language-julia"><code>function mesh_volume_contour()
    # mesh objects
    rectMesh = Rect3f(Vec3f(-0.5), Vec3f(1))
    recmesh = GeometryBasics.mesh(rectMesh)
    sphere = Sphere(Point3f(0), 1)
    # https://juliageometry.github.io/GeometryBasics.jl/stable/primitives/
    spheremesh = GeometryBasics.mesh(Tesselation(sphere, 64))
    # uses 64 for tesselation, a smoother sphere
    colors = [rand() for v in recmesh.position]
    # cloud points for volume
    x = y = z = 1..10
    vals = randn(10, 10, 10)
    fig = Figure(size=(1200, 400))
    axs = [Axis3(fig[1, i]; aspect=(1,1,1), perspectiveness=0.5) for i=1:3]
    mesh!(axs[1], recmesh; color=colors, colormap=:rainbow, shading=NoShading)
    mesh!(axs[1], spheremesh; color=(:white, 0.25), transparency=true)
    volume!(axs[2], x, y, z, vals; colormap=Reverse(:plasma))
    contour!(axs[3], x, y, z, vals; colormap=Reverse(:plasma))
    fig
end
JDS.mesh_volume_contour()</code></pre>
<figure id="fig:mesh_volume_contour">
<img src="/JuliaDataScience/im/JDS_mesh_volume_contour_.png" alt="Figure 41: Mesh volume contour." />
<figcaption aria-hidden="true">Figure 41: Mesh volume contour.</figcaption>
</figure>
<p>Note that here we are plotting two meshes into the same axis, one transparent sphere and a cube. So far, we have covered most of the 3D use-cases.</p>
<p>Taking as reference the previous example one can do the following custom plot with spheres and rectangles:</p>
<pre><code>using GeometryBasics, Colors</code></pre>
<p>For the spheres let’s do a rectangular grid. Also, we will use a different color for each one of them. Additionally, we can mix spheres and a rectangular plane. Next, we define all the necessary data.</p>
<pre class="language-julia"><code>seed!(123)
spheresGrid = [Point3f(i,j,k) for i in 1:2:10 for j in 1:2:10
    for k in 1:2:10]
colorSphere = [RGBA(i * 0.1, j * 0.1, k * 0.1, 0.75) for i in 1:2:10
    for j in 1:2:10 for k in 1:2:10]
spheresPlane = [Point3f(i,j,k) for i in 1:2.5:23 for j in 1:2.5:10
    for k in 1:2.5:4]
cmap = get(colorschemes[:plasma], range(0, 1, 50))
colorsPlane = cmap[rand(1:50,50)]
rectMesh = Rect3f(Vec3f(-1, -1, 2.1), Vec3f(16, 11, 0.5))
recmesh = GeometryBasics.mesh(rectMesh)
colors = [RGBA(rand(4)...) for v in recmesh.position]</code></pre>
<p>Then, the plot is simply done with:</p>
<pre class="language-julia"><code>function grid_spheres_and_rectangle_as_plate()
    perspectiveness=0.5
    aspect = :data
    # now the figure
    fig = with_theme(theme_dark()) do
        fig = Figure(size=(1200, 800))
        ax1 = Axis3(fig[1, 1]; aspect, perspectiveness, azimuth=0.72)
        ax2 = Axis3(fig[1, 2]; aspect, perspectiveness)
        meshscatter!(ax1, spheresGrid; color=colorSphere, markersize=1,
            shading=NoShading)
        meshscatter!(ax2, spheresPlane; color=colorsPlane, markersize=0.75,
            backlight=1.0f0)
        mesh!(recmesh; color=colors, colormap=:rainbow, shading=NoShading)
        limits!(ax1, 0, 10, 0, 10, 0, 10)
        fig
    end
    fig
end
JDS.grid_spheres_and_rectangle_as_plate()</code></pre>
<figure id="fig:grid_spheres_and_rectangle_as_plate">
<img src="/JuliaDataScience/im/JDS_grid_spheres_and_rectangle_as_plate_.png" style="width:60.0%" alt="Figure 42: Grid spheres and rectangle as plate." />
<figcaption aria-hidden="true">Figure 42: Grid spheres and rectangle as plate.</figcaption>
</figure>
<p>Here, the rectangle is semi-transparent due to the alpha channel added to the RGB color. The rectangle function is quite versatile, for instance 3D boxes are easy to implement which in turn could be used for plotting a 3D histogram. See our next example, where we are using again the <code>peaks</code> function and some additional definitions:</p>
<pre class="language-julia"><code>x, y, z = peaks(; n=15)
δx = (x[2] - x[1]) / 2
δy = (y[2] - y[1]) / 2
cbarPal = :Spectral_11
ztmp = (z .- minimum(z)) ./ (maximum(z .- minimum(z)))
cmap = get(colorschemes[cbarPal], ztmp)
cmap2 = reshape(cmap, size(z))
ztmp2 = abs.(z) ./ maximum(abs.(z)) .+ 0.15</code></pre>
<p>here <span class="math inline">\(\delta x, \delta y\)</span> are used to specify the box sizes. <code>cmap2</code> will be the color for each box and <code>ztmp2</code> will be used as a transparency parameter. See the output in the next figure.</p>
<pre class="language-julia"><code>function histogram_or_bars_in_3d()
    fig = Figure(size=(1200, 800), fontsize=26)
    ax1 = Axis3(fig[1, 1]; aspect=(1,1,1), elevation=π/6,
        perspectiveness=0.5)
    ax2 = Axis3(fig[1, 2]; aspect=(1,1,1), perspectiveness=0.5)
    rectMesh = Rect3f(Vec3f(-0.5, -0.5, 0), Vec3f(1, 1, 1))
    meshscatter!(ax1, x, y, 0 * z; marker=rectMesh, color=z[:],
        markersize=Vec3f.(2δx, 2δy, z[:]), colormap=:Spectral_11,
        shading=NoShading)
    limits!(ax1, -3.5, 3.5, -3.5, 3.5, -7.45, 7.45)
    meshscatter!(ax2, x, y, 0 * z; marker=rectMesh, color=z[:],
        markersize=Vec3f.(2δx, 2δy, z[:]), colormap=(:Spectral_11, 0.25),
        shading=NoShading, transparency=true)
    for (idx, i) in enumerate(x), (idy, j) in enumerate(y)
        rectMesh=Rect3f(Vec3f(i-δx, j-δy, 0), Vec3f(2δx, 2δy, z[idx,idy]))
        recmesh=GeometryBasics.mesh(rectMesh)
        lines!(ax2, recmesh; color=(cmap2[idx, idy], ztmp2[idx, idy]))
    end
    fig
end
JDS.histogram_or_bars_in_3d()</code></pre>
<figure id="fig:histogram_or_bars_in_3d">
<img src="/JuliaDataScience/im/JDS_histogram_or_bars_in_3d_.png" style="width:60.0%" alt="Figure 43: Histogram or bars in 3d." />
<figcaption aria-hidden="true">Figure 43: Histogram or bars in 3d.</figcaption>
</figure>
<p>Note, that you can also call <code>lines</code> or <code>wireframe</code> over a mesh object.</p>
<h3 data-number="6.9.5" id="filled-line-and-band"><span class="header-section-number">6.9.5</span> Filled Line and Band</h3>
<p>For our last example we will show how to do a filled curve in 3D with <code>band</code> and some <code>linesegments</code>:</p>
<pre class="language-julia"><code>function filled_line_and_linesegments_in_3D()
    xs = range(-3, 3, 10)
    lower = [Point3f(i, -i, 0) for i in range(0, 3, 100)]
    upper = [Point3f(i, -i, sin(i) * exp(-(i + i)))
        for i in range(0, 3, length=100)]
    fig = Figure(size=(1200, 800))
    axs = [Axis3(fig[1, i]; elevation=π/6, perspectiveness=0.5) for i=1:2]
    band!(axs[1], lower, upper; color=repeat(norm.(upper), outer=2),
        colormap=:CMRmap)
    lines!(axs[1], upper, color=:black)
    linesegments!(axs[2], cos.(xs), xs, sin.(xs); linewidth=5,
        color=1:length(xs))
    fig
end
JDS.filled_line_and_linesegments_in_3D()</code></pre>
<figure id="fig:filled_line_and_linesegments_in_3D">
<img src="/JuliaDataScience/im/JDS_filled_line_and_linesegments_in_3D_.png" style="width:60.0%" alt="Figure 44: Filled line and linesegments in 3D." />
<figcaption aria-hidden="true">Figure 44: Filled line and linesegments in 3D.</figcaption>
</figure>
<p>Finally, our journey doing 3D plots has come to an end. You can combine everything we exposed here to create amazing 3D images!</p>


<div class="bottom-nav">
    <p id="nav-prev" style="text-align: left;">
        <a class="menu-level-2" href="/JuliaDataScience/makie_layouts"><b>6.8</b> Layouts</a> <kbd>←</kbd>
        <span id="nav-next" style="float: right;">
            <kbd>→</kbd> <a class="menu-level-2" href="/JuliaDataScience/recipe_df"><b>6.10</b> A Makie recipe for a Da..</a>
        </span>
    </p>
</div>


<div class="license">
    <br/>
  <br/>
  <span style="display: flex; justify-content: center;"> <a
      style="display: flex; align-items: center; border: 1.5px solid black; border-radius: 10px;"
      href="https://opencollective.com/juliadatascience" target="_blank"> <img src="/images/coffee.png" height="18px" style="margin: 5px; display:inline"> <span style="margin-left: 4px; color: black !important">Support this project</span> </a> </span> <br> <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
    Jose Storopoli, Rik Huijzer, Lazaro Alonso
</div>
</div>
</div>
</body>
</html>