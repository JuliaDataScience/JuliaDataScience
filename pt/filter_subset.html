<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Jose Storopoli" />
  <meta name="author" content="Rik Huijzer" />
  <meta name="author" content="Lazaro Alonso" />
  <title>Filtro e Subconjunto - Julia Data Science</title>
  <link rel="shortcut icon" type="image/png" href="/pt/favicon.png"/>
  <link rel="stylesheet" href="/pt/style.css"/>
    <script src="/pt/mousetrap.min.js"></script>
    <style>
  @font-face {
    font-family: JuliaMono-Regular;
    src: url("/pt/JuliaMono-Regular.woff2");
  }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <link rel="stylesheet" href="/pt/github.min.css">
<script src="/pt/highlight.min.js"></script>
<script src="/pt/julia.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', (event) => {
    document.querySelectorAll('pre').forEach((el) => {
        hljs.highlightElement(el);
    });
});
</script>
 
</head>
<body>
<script>
function click_next() {
  var next = document.getElementById('nav-next');
  next.firstElementChild.nextElementSibling.click();
}
function click_prev() {
  var prev = document.getElementById('nav-prev');
  prev.firstElementChild.click();
}
Mousetrap.bind('right', click_next);
Mousetrap.bind('h', click_prev);
Mousetrap.bind('left', click_prev);
Mousetrap.bind('l', click_next);
</script>

<div class="books-container">
<aside class="books-menu">
<input type="checkbox" id="menu">
<label for="menu">☰</label>
<div class="books-title">
<a href="/pt/">Julia Data Science</a>
</div><br />
<span class="books-subtitle">

</span>
<div class="books-menu-content">
<li><a class="menu-level-1" href="/pt/preface"><b>1</b> Prefácio</a></li>
<li><a class="menu-level-2" href="/pt/why_data_science"><b>1.1</b> O que é Ciência de Dad..</a></li>
<li><a class="menu-level-2" href="/pt/engineering"><b>1.2</b> Engenharia de software</a></li>
<li><a class="menu-level-2" href="/pt/agradecimentos"><b>1.3</b> Agradecimentos</a></li>
<li><a class="menu-level-1" href="/pt/why_julia"><b>2</b> Por que Julia?</a></li>
<li><a class="menu-level-2" href="/pt/non-programmers"><b>2.1</b> Para os que nunca progra..</a></li>
<li><a class="menu-level-2" href="/pt/programmers"><b>2.2</b> Para programadores</a></li>
<li><a class="menu-level-2" href="/pt/julia_accomplish"><b>2.3</b> O que Julia pretende alc..</a></li>
<li><a class="menu-level-2" href="/pt/julia_wild"><b>2.4</b> Julia Por Aí</a></li>
<li><a class="menu-level-1" href="/pt/julia_basics"><b>3</b> Básico de Julia</a></li>
<li><a class="menu-level-2" href="/pt/syntax"><b>3.1</b> Sintaxe da linguagem</a></li>
<li><a class="menu-level-2" href="/pt/data_structures"><b>3.2</b> Estruturas Nativas de Da..</a></li>
<li><a class="menu-level-2" href="/pt/filesystem"><b>3.3</b> Sistema de Arquivos</a></li>
<li><a class="menu-level-2" href="/pt/standardlibrary"><b>3.4</b> Biblioteca Padrão de Ju..</a></li>
<li><a class="menu-level-1" href="/pt/dataframes"><b>4</b> DataFrames.jl</a></li>
<li><a class="menu-level-2" href="/pt/load_save"><b>4.1</b> Carregar e salvar arquiv..</a></li>
<li><a class="menu-level-2" href="/pt/indexação-e-sumarização"><b>4.2</b> Indexação e Sumarização</a></li>
<li><a class="menu-level-2" href="/pt/filter_subset"><b>4.3</b> Filtro e Subconjunto</a></li>
<li><a class="menu-level-2" href="/pt/select"><b>4.4</b> Select</a></li>
<li><a class="menu-level-2" href="/pt/missing_data"><b>4.5</b> Tipos de Dados e Dados F..</a></li>
<li><a class="menu-level-2" href="/pt/join"><b>4.6</b> Join</a></li>
<li><a class="menu-level-2" href="/pt/transformações-de-variáveis"><b>4.7</b> Transformações de Vari..</a></li>
<li><a class="menu-level-2" href="/pt/groupby_combine"><b>4.8</b> Groupby e Combine</a></li>
<li><a class="menu-level-2" href="/pt/df_performance"><b>4.9</b> Desempenho</a></li>
<li><a class="menu-level-1" href="/pt/DataVisualizationMakie"><b>5</b> Visualização de dados co..</a></li>
<li><a class="menu-level-2" href="/pt/cairomakie"><b>5.1</b> CairoMakie.jl</a></li>
<li><a class="menu-level-2" href="/pt/datavisMakie_attributes"><b>5.2</b> Atributos</a></li>
<li><a class="menu-level-2" href="/pt/themes"><b>5.3</b> Temas</a></li>
<li><a class="menu-level-2" href="/pt/usando-latexstrings.jl"><b>5.4</b> Usando LaTeXStrings.jl</a></li>
<li><a class="menu-level-2" href="/pt/makie_colors"><b>5.5</b> Cores e mapas de cores</a></li>
<li><a class="menu-level-2" href="/pt/makie_layouts"><b>5.6</b> Layouts</a></li>
<li><a class="menu-level-2" href="/pt/glmakie"><b>5.7</b> GLMakie.jl</a></li>
<li><a class="menu-level-1" href="/pt/appendix"><b>6</b> Apêndice</a></li>
<li><a class="menu-level-2" href="/pt/appendix_pkg"><b>6.1</b> Versões dos Pacotes</a></li>
<li><a class="menu-level-2" href="/pt/notation"><b>6.2</b> Formatação</a></li>
<li><a class="menu-level-1" href="/pt/referências"><b></b> Referências</a></li>
</div>
</aside>

<div class="books-content">
<h2 data-number="4.3" id="sec:filter_subset"><span class="header-section-number">4.3</span> Filtro e Subconjunto</h2>
<p>Existem duas maneiras de remover linhas de um <code>DataFrame</code>, uma é <code>filter</code> (Section <a href="/pt/filter_subset#sec:filter">4.3.1</a>) e outra é <code>subset</code> (Section <a href="/pt/filter_subset#sec:subset">4.3.2</a>). <code>filter</code> foi adicionado à biblioteca <code>DataFrames.jl</code> anteriormente, é mais poderoso e também tem uma sintaxe mais coerente em relação às bibliotecas básicas de Julia. É por isso que vamos iniciar essa seção discutindo <code>filter</code> primeiro. <code>subset</code> é mais recente e, comumente, é mais conveniente de usar.</p>
<h3 data-number="4.3.1" id="sec:filter"><span class="header-section-number">4.3.1</span> Filtro</h3>
<p>A partir de agora, nós começaremos a adentrar funcionalidades mais robustas da biblioteca <code>DataFrames.jl</code>. Para fazer isso, precisaremos aprender sobre algumas funções, como <code>select</code> e <code>filter</code>. Mas não se preocupe! Pode ser um alívio saber que o <strong>objetivo geral do design de <code>DataFrames.jl</code> é manter o número de funções que um usuário deve aprender em um mínimo<a href="/pt#fn15" class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a></strong>.</p>
<p>Como antes, retomamos a partir de <code>grades_2020</code>:</p>
<pre class="language-julia"><code>grades_2020()</code></pre>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">name</th>
<th style="text-align: right;">grade_2020</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Sally</td>
<td style="text-align: right;">1.0</td>
</tr>
<tr class="even">
<td style="text-align: right;">Bob</td>
<td style="text-align: right;">5.0</td>
</tr>
<tr class="odd">
<td style="text-align: right;">Alice</td>
<td style="text-align: right;">8.5</td>
</tr>
<tr class="even">
<td style="text-align: right;">Hank</td>
<td style="text-align: right;">4.0</td>
</tr>
</tbody>
</table>
<p>Podemos filtrar linhas usando <code>filter(source =&gt; f::Function, df)</code>. Perceba como essa função é similar à função <code>filter(f::Function, V::Vector)</code> do módulo <code>Base</code> de Julia. Isso ocorre porque <code>DataFrames.jl</code> usa <strong>despacho múltiplo</strong> (see Section <a href="/pt/julia_accomplish#sec:multiple_dispatch">2.3.3</a>) para definir um novo método de <code>filter</code> que aceita <code>DataFrame</code> como argumento.</p>
<p>À primeira vista, definir e trabalhar com uma função <code>f</code> para filtrar pode ser um pouco difícil de se usar na prática. Aguente firme, esse esforço é bem pago, uma vez que <strong>é uma forma muito poderosa de filtrar dados</strong>. Como um exemplo simples, podemos criar uma função <code>equals_alice</code> que verifica se sua entrada é igual “Alice”:</p>
<pre class="language-julia"><code>equals_alice(name::String) = name == &quot;Alice&quot;
equals_alice(&quot;Bob&quot;)</code></pre>
<pre class="output"><code>false</code></pre>
<pre class="language-julia"><code>equals_alice(&quot;Alice&quot;)</code></pre>
<pre class="output"><code>true</code></pre>
<p>Equipados com essa função, podemos usá-la como nossa função <code>f</code> para filtrar todas as linhas para as quais <code>name</code> equivale a “Alice”:</p>
<pre class="language-julia"><code>filter(:name =&gt; equals_alice, grades_2020())</code></pre>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">name</th>
<th style="text-align: right;">grade_2020</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Alice</td>
<td style="text-align: right;">8.5</td>
</tr>
</tbody>
</table>
<p>Observe que isso não funciona apenas para <code>DataFrame</code>, mas também para vetores:</p>
<pre class="language-julia"><code>filter(equals_alice, [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Dave&quot;])</code></pre>
<pre class="output"><code>[&quot;Alice&quot;]</code></pre>
<p>Podemos torná-lo um pouco menos prolixo usando uma <strong>função anônima</strong> (veja Section <a href="/pt/syntax#sec:function_anonymous">3.1.4.4</a>):</p>
<pre class="language-julia"><code>filter(n -&gt; n == &quot;Alice&quot;, [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Dave&quot;])</code></pre>
<pre class="output"><code>[&quot;Alice&quot;]</code></pre>
<p>que também podemos usar em <code>grades_2020</code>:</p>
<pre class="language-julia"><code>filter(:name =&gt; n -&gt; n == &quot;Alice&quot;, grades_2020())</code></pre>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">name</th>
<th style="text-align: right;">grade_2020</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Alice</td>
<td style="text-align: right;">8.5</td>
</tr>
</tbody>
</table>
<p>Recapitulando, esta chamada de função pode ser lida como “para cada elemento na linha <code>:name</code>, vamos chamar o elemento <code>n</code>, e checar se <code>n</code> se iguala a Alice.” Para algumas pessoas, isso ainda é muito prolixo. Por sorte, Julia adicionou uma <em>aplicação de função parcial</em> de <code>==</code>. Os detalhes não são importantes – apenas saiba que você pode usá-la como qualquer outra função:</p>
<pre class="language-julia"><code>filter(:name =&gt; ==(&quot;Alice&quot;), grades_2020())</code></pre>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">name</th>
<th style="text-align: right;">grade_2020</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Alice</td>
<td style="text-align: right;">8.5</td>
</tr>
</tbody>
</table>
<p>Para obter todas as linhas que <em>não</em> são Alice, <code>==</code> (igualdade) pode ser substituído por <code>!=</code> (desigualdade) em todos os exemplos anteriores:</p>
<pre class="language-julia"><code>filter(:name =&gt; !=(&quot;Alice&quot;), grades_2020())</code></pre>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">name</th>
<th style="text-align: right;">grade_2020</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Sally</td>
<td style="text-align: right;">1.0</td>
</tr>
<tr class="even">
<td style="text-align: right;">Bob</td>
<td style="text-align: right;">5.0</td>
</tr>
<tr class="odd">
<td style="text-align: right;">Hank</td>
<td style="text-align: right;">4.0</td>
</tr>
</tbody>
</table>
<p>Agora, para mostrar <strong>porque funções anônimas são tão poderosas</strong>, podemos criar um filtro um pouco mais complexo. Neste filtro, queremos as pessoas cujos nomes comecem com A ou B <strong>e</strong> tenham uma nota acima de 6:</p>
<pre class="language-julia"><code>function complex_filter(name, grade)::Bool
    interesting_name = startswith(name, &#39;A&#39;) || startswith(name, &#39;B&#39;)
    interesting_grade = 6 &lt; grade
    interesting_name &amp;&amp; interesting_grade
end</code></pre>
<pre class="language-julia"><code>filter([:name, :grade_2020] =&gt; complex_filter, grades_2020())</code></pre>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">name</th>
<th style="text-align: right;">grade_2020</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Alice</td>
<td style="text-align: right;">8.5</td>
</tr>
</tbody>
</table>
<h3 data-number="4.3.2" id="sec:subset"><span class="header-section-number">4.3.2</span> Subconjunto</h3>
<p>A função <code>subset</code> foi adicionada para tornar mais fácil trabalhar com valores ausentes (Section <a href="/pt/missing_data#sec:missing_data">4.5</a>). Em contraste com <code>filter</code>, <code>subset</code> funciona em colunas completas ao invés de linhas ou valores únicos. Se quisermos usar nossas funções definidas anteriormente, devemos envolvê-las dentro de <code>ByRow</code>:</p>
<pre class="language-julia"><code>subset(grades_2020(), :name =&gt; ByRow(equals_alice))</code></pre>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">name</th>
<th style="text-align: right;">grade_2020</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Alice</td>
<td style="text-align: right;">8.5</td>
</tr>
</tbody>
</table>
<p>Também perceba que <code>DataFrame</code> é agora o primeiro argumento <code>subset(df, args...)</code>, enquanto que em <code>filter</code> foi o segundo <code>filter(f, df)</code>. A razão para isso é que Julia define filtro como <code>filter(f, V::Vector)</code> e <code>DataFrames.jl</code> optou por manter a consistência com as funções Julia existentes que foram estendidas para tipos de <code>DataFrame</code>s de despacho múltiplo.</p>
<blockquote>
<p><strong><em>OBSERVAÇÃO:</em></strong> A maioria das funções nativas de <code>DataFrames.jl</code>, as quais <code>subset</code> pertence, tem uma <strong>assinatura de função consistente que sempre recebe um <code>DataFrame</code> como primeiro argumento</strong>.</p>
</blockquote>
<p>Assim como com <code>filter</code>, também podemos usar funções anônimas dentro de <code>subset</code>:</p>
<pre class="language-julia"><code>subset(grades_2020(), :name =&gt; ByRow(name -&gt; name == &quot;Alice&quot;))</code></pre>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">name</th>
<th style="text-align: right;">grade_2020</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Alice</td>
<td style="text-align: right;">8.5</td>
</tr>
</tbody>
</table>
<p>Ou, a aplicação de função parcial para <code>==</code>:</p>
<pre class="language-julia"><code>subset(grades_2020(), :name =&gt; ByRow(==(&quot;Alice&quot;)))</code></pre>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">name</th>
<th style="text-align: right;">grade_2020</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Alice</td>
<td style="text-align: right;">8.5</td>
</tr>
</tbody>
</table>
<p>Em última análise, vamos mostrar o verdadeiro poder de <code>subset</code>. Primeiro, criamos um dataset com alguns valores ausentes:</p>
<pre class="language-julia"><code>function salaries()
    names = [&quot;John&quot;, &quot;Hank&quot;, &quot;Karen&quot;, &quot;Zed&quot;]
    salary = [1_900, 2_800, 2_800, missing]
    DataFrame(; names, salary)
end
salaries()</code></pre>
<div id="tbl:salaries">
<table>
<caption>Table 6: Salaries.</caption>
<thead>
<tr class="header">
<th style="text-align: right;">names</th>
<th style="text-align: right;">salary</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">John</td>
<td style="text-align: right;">1900</td>
</tr>
<tr class="even">
<td style="text-align: right;">Hank</td>
<td style="text-align: right;">2800</td>
</tr>
<tr class="odd">
<td style="text-align: right;">Karen</td>
<td style="text-align: right;">2800</td>
</tr>
<tr class="even">
<td style="text-align: right;">Zed</td>
<td style="text-align: right;">missing</td>
</tr>
</tbody>
</table>
</div>
<p>Esses dados são sobre uma situação plausível em que você deseja descobrir os salários de seus colegas e ainda não descobriu o do Zed. Embora não queiramos incentivar essas práticas, suspeitamos que seja um exemplo interessante. Suponha que queremos saber quem ganha mais de 2.000. Se usarmos <code>filter</code>, sem levar em consideração os valores ‘faltantes,’ ele falhará:</p>
<pre class="language-julia"><code>filter(:salary =&gt; &gt;(2_000), salaries())</code></pre>
<pre class="output"><code>TypeError: non-boolean (Missing) used in boolean context
Stacktrace:
  [1] (::DataFrames.var&quot;#97#98&quot;{Base.Fix2{typeof(&gt;), Int64}})(x::Missing)
    @ DataFrames ~/.julia/packages/DataFrames/MA4YO/src/abstractdataframe/abstractdataframe.jl:1110
  ...</code></pre>
<p><code>subset</code> também falhará, mas felizmente nos apontará para uma solução fácil:</p>
<pre class="language-julia"><code>subset(salaries(), :salary =&gt; ByRow(&gt;(2_000)))</code></pre>
<pre class="output"><code>ArgumentError: missing was returned in condition number 1 but only true or false are allowed; pass skipmissing=true to skip missing values
Stacktrace:
  [1] _and(x::Missing)
    @ DataFrames ~/.julia/packages/DataFrames/MA4YO/src/abstractdataframe/subset.jl:11
  ...</code></pre>
<p>Então, só precisamos passar o argumento de palavra-chave <code>skipmissing=true</code>:</p>
<pre class="language-julia"><code>subset(salaries(), :salary =&gt; ByRow(&gt;(2_000)); skipmissing=true)</code></pre>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">names</th>
<th style="text-align: right;">salary</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Hank</td>
<td style="text-align: right;">2800</td>
</tr>
<tr class="even">
<td style="text-align: right;">Karen</td>
<td style="text-align: right;">2800</td>
</tr>
</tbody>
</table>


<div class="bottom-nav">
    <p id="nav-prev" style="text-align: left;">
        <a class="menu-level-2" href="/pt/indexação-e-sumarização"><b>4.2</b> Indexação e Sumarização</a> <kbd>←</kbd>
        <span id="nav-next" style="float: right;">
            <kbd>→</kbd> <a class="menu-level-2" href="/pt/select"><b>4.4</b> Select</a>
        </span>
    </p>
</div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn15" role="doc-endnote"><p> 15. De acordo com Bogumił Kamiński (desenvolvedor e mantenedor líder do <code>DataFrames.jl</code>) no Discourse (<a href="https://discourse.julialang.org/t/pull-dataframes-columns-to-the-front/60327/5" class="uri">https://discourse.julialang.org/t/pull-dataframes-columns-to-the-front/60327/5</a>).<a href="/pt#fnref15" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>


<div class="license">
    <br/>
  <br/>
  <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
    Jose Storopoli, Rik Huijzer, Lazaro Alonso
</div>
</div>
</div>
</body>
</html>