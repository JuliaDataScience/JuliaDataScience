<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Jose Storopoli" />
  <meta name="author" content="Rik Huijzer" />
  <meta name="author" content="Lazaro Alonso" />
  <title>GLMakie.jl - Julia Data Science</title>
  <link rel="shortcut icon" type="image/png" href="/pt/favicon.png"/>
  <link rel="stylesheet" href="/pt/style.css"/>
    <script src="/pt/mousetrap.min.js"></script>
    <style>
  @font-face {
    font-family: JuliaMono-Regular;
    src: url("/pt/JuliaMono-Regular.woff2");
  }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <link rel="stylesheet" href="/pt/github.min.css">
<script src="/pt/highlight.min.js"></script>
<script src="/pt/julia.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', (event) => {
    document.querySelectorAll('pre').forEach((el) => {
        hljs.highlightElement(el);
    });
});
</script>
 
</head>
<body>
<script>
function click_next() {
  var next = document.getElementById('nav-next');
  next.firstElementChild.nextElementSibling.click();
}
function click_prev() {
  var prev = document.getElementById('nav-prev');
  prev.firstElementChild.click();
}
Mousetrap.bind('right', click_next);
Mousetrap.bind('h', click_prev);
Mousetrap.bind('left', click_prev);
Mousetrap.bind('l', click_next);
</script>

<div class="books-container">
<aside class="books-menu">
<input type="checkbox" id="menu">
<label for="menu">☰</label>
<div class="books-title">
<a href="/pt/">Julia Data Science</a>
</div><br />
<span class="books-subtitle">

</span>
<div class="books-menu-content">
<li><a class="menu-level-1" href="/pt/preface"><b>1</b> Prefácio</a></li>
<li><a class="menu-level-2" href="/pt/why_data_science"><b>1.1</b> O que é Ciência de Dad..</a></li>
<li><a class="menu-level-2" href="/pt/engineering"><b>1.2</b> Engenharia de software</a></li>
<li><a class="menu-level-2" href="/pt/agradecimentos"><b>1.3</b> Agradecimentos</a></li>
<li><a class="menu-level-1" href="/pt/why_julia"><b>2</b> Por que Julia?</a></li>
<li><a class="menu-level-2" href="/pt/non-programmers"><b>2.1</b> Para os que nunca progra..</a></li>
<li><a class="menu-level-2" href="/pt/programmers"><b>2.2</b> Para programadores</a></li>
<li><a class="menu-level-2" href="/pt/julia_accomplish"><b>2.3</b> O que Julia pretende alc..</a></li>
<li><a class="menu-level-2" href="/pt/julia_wild"><b>2.4</b> Julia Por Aí</a></li>
<li><a class="menu-level-1" href="/pt/julia_basics"><b>3</b> Básico de Julia</a></li>
<li><a class="menu-level-2" href="/pt/syntax"><b>3.1</b> Sintaxe da linguagem</a></li>
<li><a class="menu-level-2" href="/pt/data_structures"><b>3.2</b> Estruturas Nativas de Da..</a></li>
<li><a class="menu-level-2" href="/pt/filesystem"><b>3.3</b> Sistema de Arquivos</a></li>
<li><a class="menu-level-2" href="/pt/standardlibrary"><b>3.4</b> Biblioteca Padrão de Ju..</a></li>
<li><a class="menu-level-1" href="/pt/dataframes"><b>4</b> DataFrames.jl</a></li>
<li><a class="menu-level-2" href="/pt/load_save"><b>4.1</b> Carregar e salvar arquiv..</a></li>
<li><a class="menu-level-2" href="/pt/indexação-e-sumarização"><b>4.2</b> Indexação e Sumarização</a></li>
<li><a class="menu-level-2" href="/pt/filter_subset"><b>4.3</b> Filtro e Subconjunto</a></li>
<li><a class="menu-level-2" href="/pt/select"><b>4.4</b> Select</a></li>
<li><a class="menu-level-2" href="/pt/missing_data"><b>4.5</b> Tipos de Dados e Dados F..</a></li>
<li><a class="menu-level-2" href="/pt/join"><b>4.6</b> Join</a></li>
<li><a class="menu-level-2" href="/pt/transformações-de-variáveis"><b>4.7</b> Transformações de Vari..</a></li>
<li><a class="menu-level-2" href="/pt/groupby_combine"><b>4.8</b> Groupby e Combine</a></li>
<li><a class="menu-level-2" href="/pt/df_performance"><b>4.9</b> Desempenho</a></li>
<li><a class="menu-level-1" href="/pt/DataVisualizationMakie"><b>5</b> Visualização de dados co..</a></li>
<li><a class="menu-level-2" href="/pt/cairomakie"><b>5.1</b> CairoMakie.jl</a></li>
<li><a class="menu-level-2" href="/pt/datavisMakie_attributes"><b>5.2</b> Atributos</a></li>
<li><a class="menu-level-2" href="/pt/themes"><b>5.3</b> Temas</a></li>
<li><a class="menu-level-2" href="/pt/usando-latexstrings.jl"><b>5.4</b> Usando LaTeXStrings.jl</a></li>
<li><a class="menu-level-2" href="/pt/makie_colors"><b>5.5</b> Cores e mapas de cores</a></li>
<li><a class="menu-level-2" href="/pt/makie_layouts"><b>5.6</b> Layouts</a></li>
<li><a class="menu-level-2" href="/pt/glmakie"><b>5.7</b> GLMakie.jl</a></li>
<li><a class="menu-level-1" href="/pt/appendix"><b>6</b> Apêndice</a></li>
<li><a class="menu-level-2" href="/pt/appendix_pkg"><b>6.1</b> Versões dos Pacotes</a></li>
<li><a class="menu-level-2" href="/pt/notation"><b>6.2</b> Formatação</a></li>
<li><a class="menu-level-1" href="/pt/referências"><b></b> Referências</a></li>
</div>
</aside>

<div class="books-content">
<h2 data-number="5.7" id="sec:glmakie"><span class="header-section-number">5.7</span> GLMakie.jl</h2>
<p><code>CairoMakie.jl</code> fornece todas as nossas necessidades de imagens 2D estáticas. Mas às vezes queremos interatividade, principalmente quando estamos lidando com imagens 3D. A visualização de dados em 3D também é uma prática comum para obter insights de seus dados. É aqui que <code>GLMakie.jl</code> pode ser útil, já que usa <a href="http://www.opengl.org/">OpenGL</a> como um <em>backend</em> que adiciona interatividade e capacidade de resposta a <em>plots</em>. Como antes, um <em>plot</em> simples inclui, é claro, linhas e pontos. Então, vamos começar com eles e como já sabemos como os layouts funcionam, vamos colocar isso em prática.</p>
<h3 data-number="5.7.1" id="dispersão-e-linhas"><span class="header-section-number">5.7.1</span> Dispersão e Linhas</h3>
<p>Para os gráficos de dispersão temos duas opções, a primeira é <code>scatter(x, y, z)</code> e a segunda é <code>meshscatter(x, y, z)</code>. Na primeira, os marcadores não são escalonados nas direções dos eixos, mas na segunda, porque são geometrias reais no espaço 3D. Veja o próximo exemplo:</p>
<pre><code>using GLMakie
GLMakie.activate!()</code></pre>
<pre class="language-julia"><code>function scatters_in_3D()
    seed!(123)
    xyz = randn(10, 3)
    x, y, z = xyz[:, 1], xyz[:, 2], xyz[:, 3]
    fig = Figure(resolution=(1600, 400))
    ax1 = Axis3(fig[1, 1]; aspect=(1, 1, 1), perspectiveness=0.5)
    ax2 = Axis3(fig[1, 2]; aspect=(1, 1, 1), perspectiveness=0.5)
    ax3 = Axis3(fig[1, 3]; aspect=:data, perspectiveness=0.5)
    scatter!(ax1, x, y, z; markersize=50)
    meshscatter!(ax2, x, y, z; markersize=0.25)
    hm = meshscatter!(ax3, x, y, z; markersize=0.25,
        marker=FRect3D(Vec3f(0), Vec3f(1)), color=1:size(xyz)[2],
        colormap=:plasma, transparency=false)
    Colorbar(fig[1, 4], hm, label=&quot;values&quot;, height=Relative(0.5))
    fig
end
scatters_in_3D()</code></pre>
<figure>
<img src="/pt/im/JDS_scatters_in_3D_.png" id="fig:scatters_in_3D" alt="Figure 36: Scatters in 3D." /><figcaption aria-hidden="true">Figure 36: Scatters in 3D.</figcaption>
</figure>
<p>Observe também que uma geometria diferente pode ser passada como marcadores, ou seja, um quadrado/ângulo e podemos atribuir-lhes uma <code>colormap</code> também. No painel central, pode-se obter esferas perfeitas fazendo <code>aspect = :data</code> como no painel direito.</p>
<p>E fazendo <code>lines</code> ou <code>scatterlines</code> é também bem simples:</p>
<pre class="language-julia"><code>function lines_in_3D()
    seed!(123)
    xyz = randn(10, 3)
    x, y, z = xyz[:, 1], xyz[:, 2], xyz[:, 3]
    fig = Figure(resolution=(1600, 400))
    ax1 = Axis3(fig[1, 1]; aspect=(1, 1, 1), perspectiveness=0.5)
    ax2 = Axis3(fig[1, 2]; aspect=(1, 1, 1), perspectiveness=0.5)
    ax3 = Axis3(fig[1, 3]; aspect=:data, perspectiveness=0.5)
    lines!(ax1, x, y, z; color=1:size(xyz)[2], linewidth=3)
    scatterlines!(ax2, x, y, z; markersize=50)
    hm = meshscatter!(ax3, x, y, z; markersize=0.2, color=1:size(xyz)[2])
    lines!(ax3, x, y, z; color=1:size(xyz)[2])
    Colorbar(fig[2, 1], hm; label=&quot;values&quot;, height=15, vertical=false,
        flipaxis=false, ticksize=15, tickalign=1, width=Relative(3.55 / 4))
    fig
end
lines_in_3D()</code></pre>
<figure>
<img src="/pt/im/JDS_lines_in_3D_.png" id="fig:lines_in_3D" alt="Figure 37: Lines in 3D." /><figcaption aria-hidden="true">Figure 37: Lines in 3D.</figcaption>
</figure>
<p>Plotando uma <code>surface</code> também é fácil de ser fazer assim como um <code>wireframe</code> e linhas <code>contour</code> em 3D.</p>
<h3 data-number="5.7.2" id="surfaces-wireframe-contour-contourf-e-contour3d"><span class="header-section-number">5.7.2</span> <code>surface</code>s, <code>wireframe</code>, <code>contour</code>, <code>contourf</code> e <code>contour3d</code></h3>
<p>Para mostrar estes casos, utilizaremos a seguinte função <code>peaks</code>:</p>
<pre class="language-julia"><code>function peaks(; n=49)
    x = LinRange(-3, 3, n)
    y = LinRange(-3, 3, n)
    a = 3 * (1 .- x&#39;) .^ 2 .* exp.(-(x&#39; .^ 2) .- (y .+ 1) .^ 2)
    b = 10 * (x&#39; / 5 .- x&#39; .^ 3 .- y .^ 5) .* exp.(-x&#39; .^ 2 .- y .^ 2)
    c = 1 / 3 * exp.(-(x&#39; .+ 1) .^ 2 .- y .^ 2)
    return (x, y, a .- b .- c)
end</code></pre>
<p>A saída para as diferentes funções de plotagem é:</p>
<pre class="language-julia"><code>function plot_peaks_function()
    x, y, z = peaks()
    x2, y2, z2 = peaks(; n=15)
    fig = Figure(resolution=(1600, 400), fontsize=26)
    axs = [Axis3(fig[1, i]; aspect=(1, 1, 1)) for i = 1:3]
    hm = surface!(axs[1], x, y, z)
    wireframe!(axs[2], x2, y2, z2)
    contour3d!(axs[3], x, y, z; levels=20)
    Colorbar(fig[1, 4], hm, height=Relative(0.5))
    fig
end
plot_peaks_function()</code></pre>
<figure>
<img src="/pt/im/JDS_plot_peaks_function_.png" id="fig:plot_peaks_function" alt="Figure 38: Plot peaks function." /><figcaption aria-hidden="true">Figure 38: Plot peaks function.</figcaption>
</figure>
<p>Mas, também pode ser plotado com um <code>heatmap(x, y, z)</code>, <code>contour(x, y, z)</code> ou <code>contourf(x, y, z)</code>:</p>
<pre class="language-julia"><code>function heatmap_contour_and_contourf()
    x, y, z = peaks()
    fig = Figure(resolution=(1600, 400), fontsize=26)
    axs = [Axis(fig[1, i]; aspect=DataAspect()) for i = 1:3]
    hm = heatmap!(axs[1], x, y, z)
    contour!(axs[2], x, y, z; levels=20)
    contourf!(axs[3], x, y, z)
    Colorbar(fig[1, 4], hm, height=Relative(0.5))
    fig
end
heatmap_contour_and_contourf()</code></pre>
<figure>
<img src="/pt/im/JDS_heatmap_contour_and_contourf_.png" id="fig:heatmap_contour_and_contourf" alt="Figure 39: Heatmap contour and contourf." /><figcaption aria-hidden="true">Figure 39: Heatmap contour and contourf.</figcaption>
</figure>
<p>Adicionalmente, ao mudarmos <code>Axis</code> para um <code>Axis3</code>, estes <em>plots</em> estarão automaticamente no plano x-y:</p>
<pre class="language-julia"><code>function heatmap_contour_and_contourf_in_a_3d_plane()
    x, y, z = peaks()
    fig = Figure(resolution=(1600, 400), fontsize=26)
    axs = [Axis3(fig[1, i]) for i = 1:3]
    hm = heatmap!(axs[1], x, y, z)
    contour!(axs[2], x, y, z; levels=20)
    contourf!(axs[3], x, y, z)
    Colorbar(fig[1, 4], hm, height=Relative(0.5))
    fig
end
heatmap_contour_and_contourf_in_a_3d_plane()</code></pre>
<figure>
<img src="/pt/im/JDS_heatmap_contour_and_contourf_in_a_3d_plane_.png" id="fig:heatmap_contour_and_contourf_in_a_3d_plane" alt="Figure 40: Heatmap contour and contourf in a 3d plane." /><figcaption aria-hidden="true">Figure 40: Heatmap contour and contourf in a 3d plane.</figcaption>
</figure>
<p>Algo que também é bem facil de fazer é misturar todas essas fun;óes de plotagens em um único <em>plot</em>:</p>
<pre><code>using TestImages</code></pre>
<pre class="language-julia"><code>function mixing_surface_contour3d_contour_and_contourf()
    img = testimage(&quot;coffee.png&quot;)
    x, y, z = peaks()
    cmap = :Spectral_11
    fig = Figure(resolution=(1200, 800), fontsize=26)
    ax1 = Axis3(fig[1, 1]; aspect=(1, 1, 1), elevation=pi / 6, xzpanelcolor=(:black, 0.75),
        perspectiveness=0.5, yzpanelcolor=:black, zgridcolor=:grey70,
        ygridcolor=:grey70, xgridcolor=:grey70)
    ax2 = Axis3(fig[1, 3]; aspect=(1, 1, 1), elevation=pi / 6, perspectiveness=0.5)
    hm = surface!(ax1, x, y, z; colormap=(cmap, 0.95), shading=true)
    contour3d!(ax1, x, y, z .+ 0.02; colormap=cmap, levels=20, linewidth=2)
    xmin, ymin, zmin = minimum(ax1.finallimits[])
    xmax, ymax, zmax = maximum(ax1.finallimits[])
    contour!(ax1, x, y, z; colormap=cmap, levels=20, transformation=(:xy, zmax))
    contourf!(ax1, x, y, z; colormap=cmap, transformation=(:xy, zmin))
    Colorbar(fig[1, 2], hm, width=15, ticksize=15, tickalign=1, height=Relative(0.35))
    # transformations into planes
    heatmap!(ax2, x, y, z; colormap=:viridis, transformation=(:yz, 3.5))
    contourf!(ax2, x, y, z; colormap=:CMRmap, transformation=(:xy, -3.5))
    contourf!(ax2, x, y, z; colormap=:bone_1, transformation=(:xz, 3.5))
    image!(ax2, -3 .. 3, -3 .. 2, rotr90(img); transformation=(:xy, 3.8))
    xlims!(ax2, -3.8, 3.8)
    ylims!(ax2, -3.8, 3.8)
    zlims!(ax2, -3.8, 3.8)
    fig
end
mixing_surface_contour3d_contour_and_contourf()</code></pre>
<figure>
<img src="/pt/im/JDS_mixing_surface_contour3d_contour_and_contourf_.png" id="fig:mixing_surface_contour3d_contour_and_contourf" style="width:60.0%" alt="Figure 41: Mixing surface, contour3d, contour and contourf." /><figcaption aria-hidden="true">Figure 41: Mixing surface, contour3d, contour and contourf.</figcaption>
</figure>
<p>Não é ruim, certo? É claro que qualquer <code>heatmap</code>s, <code>contour</code>s, <code>contourf</code>s ou <code>image</code> pode ser plotado em qualquer <em>plot</em>.</p>
<h3 data-number="5.7.3" id="arrows-e-streamplots"><span class="header-section-number">5.7.3</span> <code>arrows</code> e <code>streamplots</code></h3>
<p><code>arrows</code> e <code>streamplot</code> são <em>plots</em> que podem ser úteis quando queremos saber as direções que uma determinada variável seguirá. Veja uma demonstração abaixo<a href="/pt#fn18" class="footnote-ref" id="fnref18" role="doc-noteref"><sup>18</sup></a>:</p>
<pre><code>using LinearAlgebra</code></pre>
<pre class="language-julia"><code>function arrows_and_streamplot_in_3d()
    ps = [Point3f(x, y, z) for x = -3:1:3 for y = -3:1:3 for z = -3:1:3]
    ns = map(p -&gt; 0.1 * rand() * Vec3f(p[2], p[3], p[1]), ps)
    lengths = norm.(ns)
    flowField(x, y, z) = Point(-y + x * (-1 + x^2 + y^2)^2, x + y * (-1 + x^2 + y^2)^2,
        z + x * (y - z^2))
    fig = Figure(resolution=(1200, 800), fontsize=26)
    axs = [Axis3(fig[1, i]; aspect=(1, 1, 1), perspectiveness=0.5) for i = 1:2]
    arrows!(axs[1], ps, ns, color=lengths, arrowsize=Vec3f0(0.2, 0.2, 0.3),
        linewidth=0.1)
    streamplot!(axs[2], flowField, -4 .. 4, -4 .. 4, -4 .. 4, colormap=:plasma,
        gridsize=(7, 7), arrow_size=0.25, linewidth=1)
    fig
end
arrows_and_streamplot_in_3d()</code></pre>
<figure>
<img src="/pt/im/JDS_arrows_and_streamplot_in_3d_.png" id="fig:arrows_and_streamplot_in_3d" style="width:60.0%" alt="Figure 42: Arrows and streamplot in 3d." /><figcaption aria-hidden="true">Figure 42: Arrows and streamplot in 3d.</figcaption>
</figure>
<p>Outros exemplos interessantes são <code>mesh(obj)</code>, <code>volume(x, y, z, vals)</code>, e <code>contour(x, y, z, vals)</code>.</p>
<h3 data-number="5.7.4" id="mesh-e-volumes"><span class="header-section-number">5.7.4</span> <em>Mesh</em> e Volumes</h3>
<p>Visualizações de <em>mesh</em> são úteis quando você quer plotar geometrias, como uma <code>Sphere</code> ou um Retângulo, ex: <code>FRect3D</code>. Outra abordagem para visualizar pontos no espaço 3D é chamando as funções <code>volume</code> e <code>contour</code>, que implementam <a href="https://en.wikipedia.org/wiki/Ray_tracing_(graphics)"><em>ray tracing</em></a> para simular uma grande variedade de efeitos ópticos. Veja os próximos exemplos:</p>
<pre><code>using GeometryBasics</code></pre>
<pre class="language-julia"><code>function mesh_volume_contour()
    # mesh objects
    rectMesh = FRect3D(Vec3f(-0.5), Vec3f(1))
    recmesh = GeometryBasics.mesh(rectMesh)
    sphere = Sphere(Point3f(0), 1)
    # https://juliageometry.github.io/GeometryBasics.jl/stable/primitives/
    spheremesh = GeometryBasics.mesh(Tesselation(sphere, 64))
    # uses 64 for tesselation, a smoother sphere
    colors = [rand() for v in recmesh.position]
    # cloud points for volume
    x = y = z = 1:10
    vals = randn(10, 10, 10)
    fig = Figure(resolution=(1600, 400))
    axs = [Axis3(fig[1, i]; aspect=(1, 1, 1), perspectiveness=0.5) for i = 1:3]
    mesh!(axs[1], recmesh; color=colors, colormap=:rainbow, shading=false)
    mesh!(axs[1], spheremesh; color=(:white, 0.25), transparency=true)
    volume!(axs[2], x, y, z, vals; colormap=Reverse(:plasma))
    contour!(axs[3], x, y, z, vals; colormap=Reverse(:plasma))
    fig
end
mesh_volume_contour()</code></pre>
<figure>
<img src="/pt/im/JDS_mesh_volume_contour_.png" id="fig:mesh_volume_contour" alt="Figure 43: Mesh volume contour." /><figcaption aria-hidden="true">Figure 43: Mesh volume contour.</figcaption>
</figure>
<p>Note que aqui estamos traçando duas <em>mesh</em> no mesmo eixo, uma esfera transparente e um cubo. Até agora, cobrimos a maioria dos casos de uso 3D. Outro exemplo é <code>?linesegments</code>.</p>
<p>Tomando como referência o exemplo anterior, pode-se fazer o seguinte <em>plot</em> personalizado com esferas e retângulos:</p>
<pre><code>using GeometryBasics, Colors</code></pre>
<p>Para as esferas, vamos fazer um <em>grid</em> retangular. Além disso, usaremos uma cor diferente para cada uma delas. Adicionalmente, podemos misturar esferas e um plano retangular. Em seguida, definimos todos os dados necessários.</p>
<pre class="language-julia"><code>seed!(123)
spheresGrid = [Point3f(i,j,k) for i in 1:2:10 for j in 1:2:10 for k in 1:2:10]
colorSphere = [RGBA(i * 0.1, j * 0.1, k * 0.1, 0.75) for i in 1:2:10 for j in 1:2:10 for k in 1:2:10]
spheresPlane = [Point3f(i,j,k) for i in 1:2.5:20 for j in 1:2.5:10 for k in 1:2.5:4]
cmap = get(colorschemes[:plasma], LinRange(0, 1, 50))
colorsPlane = cmap[rand(1:50,50)]
rectMesh = FRect3D(Vec3f(-1, -1, 2.1), Vec3f(22, 11, 0.5))
recmesh = GeometryBasics.mesh(rectMesh)
colors = [RGBA(rand(4)...) for v in recmesh.position]</code></pre>
<p>Então, o <em>plot</em> é feito simplesmente com:</p>
<pre class="language-julia"><code>function grid_spheres_and_rectangle_as_plate()
    fig = with_theme(theme_dark()) do
        fig = Figure(resolution=(1200, 800))
        ax1 = Axis3(fig[1, 1]; aspect=:data, perspectiveness=0.5, azimuth=0.72)
        ax2 = Axis3(fig[1, 2]; aspect=:data, perspectiveness=0.5)
        meshscatter!(ax1, spheresGrid; color = colorSphere, markersize = 1,
            shading=false)
        meshscatter!(ax2, spheresPlane; color=colorsPlane, markersize = 0.75,
            lightposition=Vec3f(10, 5, 2), ambient=Vec3f(0.95, 0.95, 0.95),
            backlight=1.0f0)
        mesh!(recmesh; color=colors, colormap=:rainbow, shading=false)
        limits!(ax1, 0, 10, 0, 10, 0, 10)
        fig
    end
    fig
end
grid_spheres_and_rectangle_as_plate()</code></pre>
<figure>
<img src="/pt/im/JDS_grid_spheres_and_rectangle_as_plate_.png" id="fig:grid_spheres_and_rectangle_as_plate" style="width:60.0%" alt="Figure 44: Grid spheres and rectangle as plate." /><figcaption aria-hidden="true">Figure 44: Grid spheres and rectangle as plate.</figcaption>
</figure>
<p>Aqui, o retângulo é semi-transparente devido ao canal alfa adicionado à cor RGB. A função de retângulo é bastante versátil, por exemplo, <em>box</em> 3D é fácil implementar que por sua vez pode ser usada para traçar um histograma 3D. Veja nosso próximo exemplo, onde estamos usando novamente nossa função <code>peaks</code> e algumas definições adicionais:</p>
<pre class="language-julia"><code>x, y, z = peaks(; n=15)
δx = (x[2] - x[1]) / 2
δy = (y[2] - y[1]) / 2
cbarPal = :Spectral_11
ztmp = (z .- minimum(z)) ./ (maximum(z .- minimum(z)))
cmap = get(colorschemes[cbarPal], ztmp)
cmap2 = reshape(cmap, size(z))
ztmp2 = abs.(z) ./ maximum(abs.(z)) .+ 0.15</code></pre>
<p>aqui <span class="math inline">\(\delta x, \delta y\)</span> são usados para especificar o tamanho das <em>box</em>. <code>cmap2</code> será a cor de cada <em>box</em> e <code>ztmp2</code> será usado como o parâmetro de transparência. Veja o resultado na próxima figura.</p>
<pre class="language-julia"><code>function histogram_or_bars_in_3d()
    fig = Figure(resolution=(1200, 800), fontsize=26)
    ax1 = Axis3(fig[1, 1]; aspect=(1, 1, 1), elevation=π/6,
        perspectiveness=0.5)
    ax2 = Axis3(fig[1, 2]; aspect=(1, 1, 1), perspectiveness=0.5)
    rectMesh = FRect3D(Vec3f0(-0.5, -0.5, 0), Vec3f0(1, 1, 1))
    meshscatter!(ax1, x, y, 0*z, marker = rectMesh, color = z[:],
        markersize = Vec3f.(2δx, 2δy, z[:]), colormap = :Spectral_11,
        shading=false)
    limits!(ax1, -3.5, 3.5, -3.5, 3.5, -7.45, 7.45)
    meshscatter!(ax2, x, y, 0*z, marker = rectMesh, color = z[:],
        markersize = Vec3f.(2δx, 2δy, z[:]), colormap = (:Spectral_11, 0.25),
        shading=false, transparency=true)
    for (idx, i) in enumerate(x), (idy, j) in enumerate(y)
        rectMesh = FRect3D(Vec3f(i - δx, j - δy, 0), Vec3f(2δx, 2δy, z[idx, idy]))
        recmesh = GeometryBasics.mesh(rectMesh)
        lines!(ax2, recmesh; color=(cmap2[idx, idy], ztmp2[idx, idy]))
    end
    fig
end
histogram_or_bars_in_3d()</code></pre>
<figure>
<img src="/pt/im/JDS_histogram_or_bars_in_3d_.png" id="fig:histogram_or_bars_in_3d" style="width:60.0%" alt="Figure 45: Histogram or bars in 3d." /><figcaption aria-hidden="true">Figure 45: Histogram or bars in 3d.</figcaption>
</figure>
<p>Note que você pode também usar <code>lines</code> ou <code>wireframe</code> sobre um objeto <em>mesh</em>.</p>
<h3 data-number="5.7.5" id="linhas-preenchidas-e-band"><span class="header-section-number">5.7.5</span> Linhas Preenchidas e <code>band</code></h3>
<p>Para o nosso último exemplo vamos mostrar como fazer uma curva preenchida em 3d com <code>band</code> e alguns <code>linesegments</code>:</p>
<pre class="language-julia"><code>function filled_line_and_linesegments_in_3D()
    xs = LinRange(-3, 3, 10)
    lower = [Point3f(i, -i, 0) for i in LinRange(0, 3, 100)]
    upper = [Point3f(i, -i, sin(i) * exp(-(i + i))) for i in range(0, 3, length=100)]
    fig = Figure(resolution=(1200, 800))
    axs = [Axis3(fig[1, i]; elevation=pi/6, perspectiveness=0.5) for i = 1:2]
    band!(axs[1], lower, upper, color=repeat(norm.(upper), outer=2), colormap=:CMRmap)
    lines!(axs[1], upper, color=:black)
    linesegments!(axs[2], cos.(xs), xs, sin.(xs), linewidth=5, color=1:length(xs))
    fig
end
filled_line_and_linesegments_in_3D()</code></pre>
<figure>
<img src="/pt/im/JDS_filled_line_and_linesegments_in_3D_.png" id="fig:filled_line_and_linesegments_in_3D" style="width:60.0%" alt="Figure 46: Filled line and linesegments in 3D." /><figcaption aria-hidden="true">Figure 46: Filled line and linesegments in 3D.</figcaption>
</figure>
<p>Finalmente, nossa jornada fazendo <em>plots</em> 3D chegou ao fim. Você pode combinar tudo o que expostos aqui para criar imagens 3D incríveis!</p>


<div class="bottom-nav">
    <p id="nav-prev" style="text-align: left;">
        <a class="menu-level-2" href="/pt/makie_layouts"><b>5.6</b> Layouts</a> <kbd>←</kbd>
        <span id="nav-next" style="float: right;">
            <kbd>→</kbd> <a class="menu-level-1" href="/pt/appendix"><b>6</b> Apêndice</a>
        </span>
    </p>
</div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn18" role="doc-endnote"><p> 18. Estamos usando o módulo <code>LinearAlgebra</code> da biblioteca padrão de Julia.<a href="/pt#fnref18" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>


<div class="license">
    <br/>
  <br/>
  <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
    Jose Storopoli, Rik Huijzer, Lazaro Alonso
</div>
</div>
</div>
</body>
</html>