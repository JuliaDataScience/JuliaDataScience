<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Jose Storopoli" />
  <meta name="author" content="Rik Huijzer" />
  <meta name="author" content="Lazaro Alonso" />
  <title>O que Julia pretende alcançar? - Julia Data Science</title>
  <link rel="shortcut icon" type="image/png" href="/pt/favicon.png"/>
  <link rel="stylesheet" href="/pt/style.css"/>
    <script src="/pt/mousetrap.min.js"></script>
    <style>
  @font-face {
    font-family: JuliaMono-Regular;
    src: url("/pt/JuliaMono-Regular.woff2");
  }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <link rel="stylesheet" href="/pt/github.min.css">
<script src="/pt/highlight.min.js"></script>
<script src="/pt/julia.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', (event) => {
    document.querySelectorAll('pre').forEach((el) => {
        hljs.highlightElement(el);
    });
});
</script>
 
</head>
<body>
<script>
function click_next() {
  var next = document.getElementById('nav-next');
  next.firstElementChild.nextElementSibling.click();
}
function click_prev() {
  var prev = document.getElementById('nav-prev');
  prev.firstElementChild.click();
}
Mousetrap.bind('right', click_next);
Mousetrap.bind('h', click_prev);
Mousetrap.bind('left', click_prev);
Mousetrap.bind('l', click_next);
</script>

<div class="books-container">
<aside class="books-menu">
<input type="checkbox" id="menu">
<label for="menu">☰</label>
<div class="books-title">
<a href="/pt/">Julia Data Science</a>
</div><br />
<span class="books-subtitle">

</span>
<div class="books-menu-content">
<li><a class="menu-level-1" href="/pt/preface"><b>1</b> Prefácio</a></li>
<li><a class="menu-level-2" href="/pt/why_data_science"><b>1.1</b> O que é Ciência de Dad..</a></li>
<li><a class="menu-level-2" href="/pt/engineering"><b>1.2</b> Engenharia de software</a></li>
<li><a class="menu-level-2" href="/pt/agradecimentos"><b>1.3</b> Agradecimentos</a></li>
<li><a class="menu-level-1" href="/pt/why_julia"><b>2</b> Por que Julia?</a></li>
<li><a class="menu-level-2" href="/pt/non-programmers"><b>2.1</b> Para os que nunca progra..</a></li>
<li><a class="menu-level-2" href="/pt/programmers"><b>2.2</b> Para programadores</a></li>
<li><a class="menu-level-2" href="/pt/julia_accomplish"><b>2.3</b> O que Julia pretende alc..</a></li>
<li><a class="menu-level-2" href="/pt/julia_wild"><b>2.4</b> Julia Por Aí</a></li>
<li><a class="menu-level-1" href="/pt/julia_basics"><b>3</b> Básico de Julia</a></li>
<li><a class="menu-level-2" href="/pt/syntax"><b>3.1</b> Sintaxe da linguagem</a></li>
<li><a class="menu-level-2" href="/pt/data_structures"><b>3.2</b> Estruturas Nativas de Da..</a></li>
<li><a class="menu-level-2" href="/pt/filesystem"><b>3.3</b> Sistema de Arquivos</a></li>
<li><a class="menu-level-2" href="/pt/standardlibrary"><b>3.4</b> Biblioteca Padrão de Ju..</a></li>
<li><a class="menu-level-1" href="/pt/dataframes"><b>4</b> DataFrames.jl</a></li>
<li><a class="menu-level-2" href="/pt/load_save"><b>4.1</b> Carregar e salvar arquiv..</a></li>
<li><a class="menu-level-2" href="/pt/indexação-e-sumarização"><b>4.2</b> Indexação e Sumarização</a></li>
<li><a class="menu-level-2" href="/pt/filter_subset"><b>4.3</b> Filtro e Subconjunto</a></li>
<li><a class="menu-level-2" href="/pt/select"><b>4.4</b> Select</a></li>
<li><a class="menu-level-2" href="/pt/missing_data"><b>4.5</b> Tipos de Dados e Dados F..</a></li>
<li><a class="menu-level-2" href="/pt/join"><b>4.6</b> Join</a></li>
<li><a class="menu-level-2" href="/pt/transformações-de-variáveis"><b>4.7</b> Transformações de Vari..</a></li>
<li><a class="menu-level-2" href="/pt/groupby_combine"><b>4.8</b> Groupby e Combine</a></li>
<li><a class="menu-level-2" href="/pt/df_performance"><b>4.9</b> Desempenho</a></li>
<li><a class="menu-level-1" href="/pt/DataVisualizationMakie"><b>5</b> Visualização de dados co..</a></li>
<li><a class="menu-level-2" href="/pt/cairomakie"><b>5.1</b> CairoMakie.jl</a></li>
<li><a class="menu-level-2" href="/pt/datavisMakie_attributes"><b>5.2</b> Atributos</a></li>
<li><a class="menu-level-2" href="/pt/themes"><b>5.3</b> Temas</a></li>
<li><a class="menu-level-2" href="/pt/usando-latexstrings.jl"><b>5.4</b> Usando LaTeXStrings.jl</a></li>
<li><a class="menu-level-2" href="/pt/makie_colors"><b>5.5</b> Cores e mapas de cores</a></li>
<li><a class="menu-level-2" href="/pt/makie_layouts"><b>5.6</b> Layouts</a></li>
<li><a class="menu-level-2" href="/pt/glmakie"><b>5.7</b> GLMakie.jl</a></li>
<li><a class="menu-level-1" href="/pt/appendix"><b>6</b> Apêndice</a></li>
<li><a class="menu-level-2" href="/pt/appendix_pkg"><b>6.1</b> Versões dos Pacotes</a></li>
<li><a class="menu-level-2" href="/pt/notation"><b>6.2</b> Formatação</a></li>
<li><a class="menu-level-1" href="/pt/referências"><b></b> Referências</a></li>
</div>
</aside>

<div class="books-content">
<h2 data-number="2.3" id="sec:julia_accomplish"><span class="header-section-number">2.3</span> O que Julia pretende alcançar?</h2>
<blockquote>
<p><strong><em>NOTE:</em></strong> Nessa seção explicaremos com detalhes o que faz de Julia uma linguagem de programação brilhante. Se essa explicação for muito técnica para você, vá direto para Section <a href="/pt/dataframes#sec:dataframes">4</a> para aprender sobre dados tabulares com <code>DataFrames.jl</code>.</p>
</blockquote>
<p>A linguagem de programação Julia <span class="citation" data-cites="bezanson2017julia">(<a href="/pt/references#ref-bezanson2017julia" role="doc-biblioref">Bezanson et al., 2017</a>)</span> é relativamente nova, foi lançada em 2012, e procura ser <strong>fácil e rápida</strong>. Ela “roda como C<a href="/pt#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>, mas lê como Python” <span class="citation" data-cites="perkelJuliaComeSyntax2019">(<a href="/pt/references#ref-perkelJuliaComeSyntax2019" role="doc-biblioref">Perkel, 2019</a>)</span>. Foi idealizada inicialmente para computação científica, capaz de lidar com <strong>uma grande quantidade de dados e demanda computacional</strong> sendo, ao mesmo tempo, <strong>fácil de manipular, criar e prototipar códigos</strong>.</p>
<p>Os criadores de Julia explicaram porque desenvolveram a linguagem em uma postagem em seu blog em <a href="https://julialang.org/blog/2012/02/why-we-created-julia/">2012</a>. Eles afirmam:</p>
<blockquote>
<p>Somos ambiciosos: queremos mais. Queremos uma linguagem open source, com uma licença permissiva. Queremos a velocidade do C com o dinamismo do Ruby. Queremos uma linguagem que seja homoicônica, com verdadeiros macros como Lisp, mas com uma notação matemática óbvia e familiar como Matlab. Queremos algo que seja útil para programação em geral como Python, fácil para estatística como R, tão natural para processamento de strings quanto Perl, tão poderoso para álgebra linear quanto Matlab, tão bom para integrar programas juntos quanto shell. Algo que seja simples de aprender, mas que deixe os hackers mais sérios felizes. Queremos que seja interativa e que seja compilada.</p>
</blockquote>
<p>A maioria dos usuários se sentem atraídos por Julia em função da sua <strong>velocidade superior</strong>. Afinal, Julia é membro de um clube prestigiado e exclusivo. O <a href="https://www.hpcwire.com/off-the-wire/julia-joins-petaflop-club/"><strong>petaflop club</strong></a> é composto por linguagens que excedem a velocidade de <strong>um petaflop<a href="/pt#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> no desempenho máximo</strong>. Atualmente, apenas C, C++, Fortran e Julia fazem parte do <a href="https://www.nextplatform.com/2017/11/28/julia-language-delivers-petascale-hpc-performance/">petaflop club</a>.</p>
<p>Mas velocidade não é tudo que Julia pode oferecer. A <strong>facilidade de uso</strong>, <strong>o suporte a caracteres Unicode</strong> e ser uma linguagem que torna <strong>o compartilhamento de códigos algo muito simples</strong> são algumas das características de Julia. Falaremos de todas essas qualidades nessa seção, mas focaremos no compartilhamento de códigos por enquanto.</p>
<p>O ecossistema de pacotes de Julia é algo único. Permite não só o compartilhamento de códigos, como também permite a criação de tipos definidos pelos usuários. Por exemplo, o <code>pandas</code> do Python usa seu próprio tipo de <code>DateTime</code> para lidar com datas. O mesmo ocorre com o pacote <code>lubridate</code> do tidyverse do R, que também define o seu tipo próprio de <code>datetime</code> para lidar com datas. Julia não precisa disso, ela tem todos os tipos e funcionalidades de datas incluidas na sua biblioteca padrão. Isso significa que outros pacotes não precisam se preocupar com datas. Eles só precisam estender os tipos de <code>DateTime</code> de Julia para novas funcionalidades, ao definirem novas funções, sem a necessidade de definirem novos tipos. O módulo <code>Dates</code> de Julia faz coisas incríveis, mas estamos nos adiantando. Primeiro, vamos falar de outras características de Julia.</p>
<h3 data-number="2.3.1" id="julia-versus-outras-linguagens-de-programação"><span class="header-section-number">2.3.1</span> Julia Versus outras linguagens de programação</h3>
<p>Em Figure <a href="/pt#fig:language_comparison">2</a>, uma representação altamente opinativa, dividimos as principais linguagens open source e de computação científica em um diagrama 2x2 com dois eixos: <strong>Lento-Rápido</strong> e <strong>Fácil-Difícil</strong>. Deixamos de fora as linguagens de código fechado, porque os benefícios são maiores quando permitimos que outras pessoas usem nossos códigos gratuitamente, assim como quando têm a liberdade para inspecionar elas mesmas o código fonte para sanar dúvidas e resolver problemas.</p>
<p>Consideramos que o C++ e o FORTRAN estão no quadrante Difícil e Rápido. Por serem linguagens estáticas que precisam de compilação, verificação de tipo e outros cuidados e atenção profissional, elas são realmente difíceis de aprender e lentas para prototipar. A vantagem é que elas são linguagens <strong>muito rápidas</strong>.</p>
<p>R e Python estão no quadrante Fácil e Lento. Elas são linguagens dinâmicas, que não são compiladas e executam em tempo de execução. Por causa disso, elas são fáceis de aprender e rápidas para prototipar. Claro que isso tem desvantagens: elas são linguagens <strong>muito lentas</strong>.</p>
<p>Julia é a única linguagem no quadrante Fácil e Rápido. Nós não conhecemos nenhuma linguagem séria que almejaria ser Difícil e Lenta, por isso esse quadrante está vazio.</p>
<figure>
<img src="images/language_comparisons.png" id="fig:language_comparison" alt="Figure 2: Comparações entre linguagens de computação científicas: logos para FORTRAN, C++, Python, R e Julia." /><figcaption aria-hidden="true">Figure 2: Comparações entre linguagens de computação científicas: logos para FORTRAN, C++, Python, R e Julia.</figcaption>
</figure>
<p><strong>Julia é rápida! Muito rápida!</strong> Foi desenvolvida para ser veloz desde o início. E alcança esse objetivo por meio do despacho múltiplo. Basicamente, a ideia é gerar códigos LLVM<a href="/pt#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a> muito eficientes. Códigos LLVM, também conhecidos como instruções LLVM, são de baixo-nível, ou seja, muito próximos das operações reais que seu computador está executando. Portanto, em essência, Julia converte o código que você escreveu — que é fácil de se ler — em código de máquina LLVM, que é muito difícil para humanos lerem, mas muito fácil para um computador. Por exemplo, se você definir uma função que recebe um argumento e passar um inteiro para a função, Julia criará um <code>MethodInstance</code> <em>especializado</em>. Na próxima vez que você passar um inteiro como argumento para a função, Julia buscará o <code>MethodInstance</code> criado anteriormente e redirecionará a execução a ele. Agora, o <strong>grande</strong> truque é que você também pode fazer isso dentro de uma função que chama uma outra função. Por exemplo, se certo tipo de dado é passado dentro da função <code>f</code> e <code>f</code> chama a função <code>g</code>, e se os tipos de dados passados para <code>g</code> são conhecidos e sempre os mesmos, então a função <code>g</code> gerada pode ser codificada de forma pré-definida pelo Julia na função <code>f</code>! Isso significa que Julia não precisa sequer buscar <code>MethodInstances</code> de <code>f</code> para <code>g</code>, pois o código consegue rodar de forma eficiente. A compensação aqui é que existem casos onde as suposições anteriores sobre a decodificação dos <code>MethodInstances</code> são invalidadas. Então, o <code>MethodInstance</code> precisa ser recriado, o que leva tempo. Além disso, a desvantagem é que também leva tempo para inferir o que pode ser codificado de forma pré-definida e o que não pode. Isso explica por que Julia demora para executar um código pela primeira vez: ela está otimizando seu código em segundo-plano. A segunda e subsequentes execuções serão extremamente rápidas.</p>
<p>O compilador, por sua vez, faz o que ele faz de melhor: otimiza o código de máquina<a href="/pt#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a>. Você encontra <a href="https://julialang.org/benchmarks/">benchmarks</a> para Julia e para outras linguagens aqui. Figure <a href="/pt#fig:benchmarks">3</a> foi retirado da <a href="https://julialang.org/benchmarks/">seção de Benchmarks do site de Julia<a href="/pt#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a></a>. Como você pode perceber, Julia é <strong>de fato</strong> rápida.</p>
<figure>
<img src="images/benchmarks.png" id="fig:benchmarks" alt="Figure 3: Julia versus outras linguagens de programação." /><figcaption aria-hidden="true">Figure 3: Julia versus outras linguagens de programação.</figcaption>
</figure>
<p>Nós realmente acreditamos em Julia. Caso contrário, não teríamos escrito este livro. Nós acreditamos que Julia é <strong>o futuro da computação científica e da análise de dados científicos</strong>. Ela permite que o usuário desenvolva códigos rápidos e poderosos com uma sintaxe simples. Normalmente, pesquisadores desenvolvem códigos usando linguagens fáceis, mas muito lentas. Uma vez que o código rode corretamente e cumpra seus objetivos, aí começa o processo de conversão do código para uma linguagem rápida, porém difícil. Esse é o “problema das duas linguagens” e discutiremos ele melhor a seguir.</p>
<h3 data-number="2.3.2" id="sec:two_language"><span class="header-section-number">2.3.2</span> O Problema das Duas Linguagens</h3>
<p>O “Problema das Duas Linguagens” é bastante comum na computação científica, quando um pesquisador concebe um algoritmo, ou quando desenvolve uma solução para um problema, ou mesmo quando realiza algum tipo de análise. Em seguida, a solução é prototipada em uma linguagem fácil de codificar (como Python ou R). Se o protótipo funciona, o pesquisador codifica em uma linguagem rápida que, em geral, não é fácil de prototipar (como C++ ou FORTRAN). Assim, temos duas linguagens envolvidas no processo de desenvolvimento de uma nova solução. Uma que é fácil de prototipar, mas não é adequada para implementação (principalmente por ser lenta). E outra que não é tão simples de codificar e, consequentemente, não é fácil de prototipar, mas adequada para implementação porque é rápida. Julia evita esse tipo de situação por ser a <strong>a mesma linguagem que você prototipa (fácil de usar) e implementa a solução (rápida)</strong>.</p>
<p>Além disso, Julia permite que você use <strong>caracteres Unicode como variáveis ou parâmetros</strong>. Isso significa que não é preciso mais usar <code>sigma</code> ou <code>sigma_i</code>: ao invés disso use apenas <span class="math inline">\(σ\)</span> ou <span class="math inline">\(σᵢ\)</span> como você faria em notação matemática. Quando você vê o código de um algoritmo ou para uma equação matemática, você vê quase a mesma notação e expressões idiomáticas. Chamamos esse recurso poderoso de <strong>“Relação Um para Um entre Código e Matemática”</strong>.</p>
<p>Acreditamos que o “Problema das Duas Linguagens” e a “Relação Um para Um entre Código e Matemática” são melhor descritos por um dos criadores de Julia, Alan Edelman, em um <a href="https://youtu.be/qGW0GT1rCvs">TEDx Talk</a> <span class="citation" data-cites="tedxtalksProgrammingLanguageHeal2020">(<a href="/pt/references#ref-tedxtalksProgrammingLanguageHeal2020" role="doc-biblioref">TEDx Talks, 2020</a>)</span>.</p>
<style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style>
<div class="embed-container">
<iframe src="https://www.youtube.com/embed/qGW0GT1rCvs" frameborder="0" allowfullscreen>
</iframe>
</div>
<h3 data-number="2.3.3" id="sec:multiple_dispatch"><span class="header-section-number">2.3.3</span> Despacho Múltiplo</h3>
<p>Despacho múltiplo é um recurso poderoso que nos permite estender funções existentes ou definir comportamento personalizado e complexo para novos tipos. Suponha que você queira definir dois novos <code>struct</code>s para denotar dois animais diferentes:</p>
<pre class="language-julia"><code>abstract type Animal end
struct Fox &lt;: Animal
    weight::Float64
end
struct Chicken &lt;: Animal
    weight::Float64
end</code></pre>
<p>Basicamente, isso diz “defina uma raposa, que é um animal” e “defina uma galinha, que é um animal.” Em seguida, podemos ter uma raposa chamada Fiona e uma galinha chamada Big Bird.</p>
<pre class="language-julia"><code>fiona = Fox(4.2)
big_bird = Chicken(2.9)</code></pre>
<p>A seguir, queremos saber quanto elas pesam juntas, para o qual podemos escrever uma função:</p>
<pre class="language-julia"><code>combined_weight(A1::Animal, A2::Animal) = A1.weight + A2.weight</code></pre>
<pre class="output"><code>combined_weight (generic function with 1 method)</code></pre>
<p>E queremos saber se elas vão se dar bem. Uma maneira de implementar isso é usar condicionais:</p>
<pre class="language-julia"><code>function naive_trouble(A::Animal, B::Animal)
    if A isa Fox &amp;&amp; B isa Chicken
        return true
    elseif A isa Chicken &amp;&amp; B isa Fox
        return true
    elseif A isa Chicken &amp;&amp; B isa Chicken
        return false
    end
end</code></pre>
<pre class="output"><code>naive_trouble (generic function with 1 method)</code></pre>
<p>Agora, vamos ver se deixar Fiona e Big Bird juntas daria problema:</p>
<pre class="language-julia"><code>naive_trouble(fiona, big_bird)</code></pre>
<pre class="output"><code>true</code></pre>
<p>OK, isso parece correto. Escrevendo a função <code>naive_trouble</code> parece ser o suficiente. No entanto, usar despacho múltiplo para criar uma nova função <code>trouble</code> pode ser benéfico. Vamos criar novas funções:</p>
<pre class="language-julia"><code>trouble(F::Fox, C::Chicken) = true
trouble(C::Chicken, F::Fox) = true
trouble(C1::Chicken, C2::Chicken) = false</code></pre>
<pre class="output"><code>trouble (generic function with 3 methods)</code></pre>
<p>Depois da definição dos métodos, <code>trouble</code> fornece o mesmo resultado que <code>naive_trouble</code>. Por exemplo:</p>
<pre class="language-julia"><code>trouble(fiona, big_bird)</code></pre>
<pre class="output"><code>true</code></pre>
<p>E deixar Big Bird sozinha com outra galinha chamada Dora também é bom</p>
<pre class="language-julia"><code>dora = Chicken(2.2)
trouble(dora, big_bird)</code></pre>
<pre class="output"><code>false</code></pre>
<p>Portanto, neste caso, a vantagem do despacho múltiplo é que você pode apenas declarar tipos e Julia encontrará o método correto para seus tipos. Ainda mais, para muitos casos quando o despacho múltiplo é usado dentro do código, o compilador Julia irá realmente otimizar as chamadas de função. Por exemplo, poderíamos escrever:</p>
<pre><code>function trouble(A::Fox, B::Chicken, C::Chicken)
    return trouble(A, B) || trouble(B, C) || trouble(C, A)
end</code></pre>
<p>Dependendo do contexto, Julia pode otimizar isso para:</p>
<pre><code>function trouble(A::Fox, B::Chicken, C::Chicken)
    return true || false || true
end</code></pre>
<p>porque o compilador <strong>sabe</strong> que <code>A</code> é a raposa, <code>B</code> é a galinha e então isso pode ser substituído pelo conteúdo do método <code>trouble(F::Fox, C::Chicken)</code>. O mesmo vale para <code>trouble(C1::Chicken, C2::Chicken)</code>. Em seguida, o compilador pode otimizar isso para:</p>
<pre><code>function trouble(A::Fox, B::Chicken, C::Chicken)
    return true
end</code></pre>
<p>Outro benefício do despacho múltiplo é que quando outra pessoa chega e quer comparar os animais existentes com seu animal, uma zebra por exemplo, é possível. Em seu pacote, eles podem definir um Zebra:</p>
<pre class="language-julia"><code>struct Zebra &lt;: Animal
    weight::Float64
end</code></pre>
<p>e também como as interações com os animais existentes seriam:</p>
<pre class="language-julia"><code>trouble(F::Fox, Z::Zebra) = false
trouble(Z::Zebra, F::Fox) = false
trouble(C::Chicken, Z::Zebra) = false
trouble(Z::Zebra, F::Fox) = false</code></pre>
<pre class="output"><code>trouble (generic function with 6 methods)</code></pre>
<p>Agora, podemos ver se Marty (nossa zebra) está a salvo com Big Bird:</p>
<pre class="language-julia"><code>marty = Zebra(412)
trouble(big_bird, marty)</code></pre>
<pre class="output"><code>false</code></pre>
<p>Ainda melhor, conseguimos calcular <strong>o peso combinado de zebras e outros animais sem definir qualquer função extra</strong>:</p>
<pre class="language-julia"><code>combined_weight(big_bird, marty)</code></pre>
<pre class="output"><code>414.9</code></pre>
<p>Então, em resumo, o código que foi escrito pensando apenas para Raposa e Galinha funciona para tipos que <strong>ele nunca tinham visto</strong>! Na prática, isso significa que Julia facilita o reuso do código de outros projetos.</p>
<p>Se você está tão animado quanto nós com o despacho múltiplo, aqui estão mais dois exemplos aprofundados. O primeiro é uma <a href="https://storopoli.io/Bayesian-Julia/pages/1_why_Julia/#example_one-hot_vector">rápida e elegante implementação de um vetor one-hot</a> por <span class="citation" data-cites="storopoli2021bayesianjulia"><a href="/pt/references#ref-storopoli2021bayesianjulia" role="doc-biblioref">Storopoli</a> (<a href="/pt/references#ref-storopoli2021bayesianjulia" role="doc-biblioref">2021</a>)</span>. O segundo é uma entrevista com <a href="https://www.chrisrackauckas.com/">Christopher Rackauckas</a> no <a href="https://youtu.be/moyPIhvw4Nk?t=2107">canal do YouTube de Tanmay Bakshi</a> (assista do minuto 35:07 em diante) <span class="citation" data-cites="tanmaybakshiBakingKnowledgeMachine2021">(<a href="/pt/references#ref-tanmaybakshiBakingKnowledgeMachine2021" role="doc-biblioref">tanmay bakshi, 2021</a>)</span>. Chris explica que, enquanto utilizava o <a href="https://diffeq.sciml.ai/dev/"><code>DifferentialEquations.jl</code></a>, um pacote que ele desenvolveu e mantém atualmente, um usuário registrou um problema que seu solucionador de Equações Diferenciais Ordinais (EDO) com quaternions baseado em GPU não funcionava. Chris ficou bastante surpreso com este pedido, já que ele não esperava que alguém combinasse cálculos da GPU com quaternions e resolvendo EDOs. Ele ficou ainda mais surpreso quando descobriu que o usuário cometeu um pequeno erro e que tudo funcionou. A maior parte do mérito é devido ao múltiplo despacho e alto compartilhamento de código/tipos definidos pelo usuário.</p>
<p>Para concluir, pensamos que o despacho múltiplo é melhor explicado por um dos criadores de Julia: <a href="https://youtu.be/kc9HwsxE1OY">Stefan Karpinski na JuliaCon 2019</a>.</p>
<style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style>
<div class="embed-container">
<iframe src="https://www.youtube.com/embed/kc9HwsxE1OY" frameborder="0" allowfullscreen>
</iframe>
</div>


<div class="bottom-nav">
    <p id="nav-prev" style="text-align: left;">
        <a class="menu-level-2" href="/pt/programmers"><b>2.2</b> Para programadores</a> <kbd>←</kbd>
        <span id="nav-next" style="float: right;">
            <kbd>→</kbd> <a class="menu-level-2" href="/pt/julia_wild"><b>2.4</b> Julia Por Aí</a>
        </span>
    </p>
</div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn8" role="doc-endnote"><p> 8. às vezes até mais rápido<a href="/pt#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9" role="doc-endnote"><p> 9. um petaflop equivale a mil trilhões, ou um quatrilhão de operações com pontos flutuantes por segundo.<a href="/pt#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10" role="doc-endnote"><p> 10. LLVM significa “Máquina Virtual de Baixo-Nível,” ou, em inglês, <strong>L</strong>ow <strong>L</strong>evel <strong>V</strong>irtual <strong>M</strong>achine. Você pode encontrar mais sobre a LLVM no site: (<a href="http://llvm.org" class="uri">http://llvm.org</a>).<a href="/pt#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11" role="doc-endnote"><p> 11. se quer saber mais sobre como Julia foi projetada, acesse <span class="citation" data-cites="bezanson2017julia"><a href="/pt/references#ref-bezanson2017julia" role="doc-biblioref">Bezanson et al.</a> (<a href="/pt/references#ref-bezanson2017julia" role="doc-biblioref">2017</a>)</span>.<a href="/pt#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn12" role="doc-endnote"><p> 12. observe que os resultados de Julia descritos acima não incluem o tempo de compilação.<a href="/pt#fnref12" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>


<div class="license">
    <br/>
  <br/>
  <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
    Jose Storopoli, Rik Huijzer, Lazaro Alonso
</div>
</div>
</div>
</body>
</html>