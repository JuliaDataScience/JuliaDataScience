<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Jose Storopoli" />
  <meta name="author" content="Rik Huijzer" />
  <meta name="author" content="Lazaro Alonso" />
  <title>Biblioteca Padrão de Julia - Julia Data Science</title>
  <link rel="shortcut icon" type="image/png" href="/pt/favicon.png"/>
  <link rel="stylesheet" href="/pt/style.css"/>
    <script src="/pt/mousetrap.min.js"></script>
    <style>
  @font-face {
    font-family: JuliaMono-Regular;
    src: url("/pt/JuliaMono-Regular.woff2");
  }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <link rel="stylesheet" href="/pt/github.min.css">
<script src="/pt/highlight.min.js"></script>
<script src="/pt/julia.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', (event) => {
    document.querySelectorAll('pre').forEach((el) => {
        hljs.highlightElement(el);
    });
});
</script>
 
</head>
<body>
<script>
function click_next() {
  var next = document.getElementById('nav-next');
  next.firstElementChild.nextElementSibling.click();
}
function click_prev() {
  var prev = document.getElementById('nav-prev');
  prev.firstElementChild.click();
}
Mousetrap.bind('right', click_next);
Mousetrap.bind('h', click_prev);
Mousetrap.bind('left', click_prev);
Mousetrap.bind('l', click_next);
</script>

<div class="books-container">
<aside class="books-menu">
<input type="checkbox" id="menu">
<label for="menu">☰</label>
<div class="books-title">
<a href="/pt/">Julia Data Science</a>
</div><br />
<span class="books-subtitle">

</span>
<div class="books-menu-content">
<li><a class="menu-level-1" href="/pt/preface"><b>1</b> Prefácio</a></li>
<li><a class="menu-level-2" href="/pt/why_data_science"><b>1.1</b> O que é Ciência de Dad..</a></li>
<li><a class="menu-level-2" href="/pt/engineering"><b>1.2</b> Engenharia de software</a></li>
<li><a class="menu-level-2" href="/pt/agradecimentos"><b>1.3</b> Agradecimentos</a></li>
<li><a class="menu-level-1" href="/pt/why_julia"><b>2</b> Por que Julia?</a></li>
<li><a class="menu-level-2" href="/pt/non-programmers"><b>2.1</b> Para os que nunca progra..</a></li>
<li><a class="menu-level-2" href="/pt/programmers"><b>2.2</b> Para programadores</a></li>
<li><a class="menu-level-2" href="/pt/julia_accomplish"><b>2.3</b> O que Julia pretende alc..</a></li>
<li><a class="menu-level-2" href="/pt/julia_wild"><b>2.4</b> Julia Por Aí</a></li>
<li><a class="menu-level-1" href="/pt/julia_basics"><b>3</b> Básico de Julia</a></li>
<li><a class="menu-level-2" href="/pt/syntax"><b>3.1</b> Sintaxe da linguagem</a></li>
<li><a class="menu-level-2" href="/pt/data_structures"><b>3.2</b> Estruturas Nativas de Da..</a></li>
<li><a class="menu-level-2" href="/pt/filesystem"><b>3.3</b> Sistema de Arquivos</a></li>
<li><a class="menu-level-2" href="/pt/standardlibrary"><b>3.4</b> Biblioteca Padrão de Ju..</a></li>
<li><a class="menu-level-1" href="/pt/dataframes"><b>4</b> DataFrames.jl</a></li>
<li><a class="menu-level-2" href="/pt/load_save"><b>4.1</b> Carregar e salvar arquiv..</a></li>
<li><a class="menu-level-2" href="/pt/indexação-e-sumarização"><b>4.2</b> Indexação e Sumarização</a></li>
<li><a class="menu-level-2" href="/pt/filter_subset"><b>4.3</b> Filtro e Subconjunto</a></li>
<li><a class="menu-level-2" href="/pt/select"><b>4.4</b> Select</a></li>
<li><a class="menu-level-2" href="/pt/missing_data"><b>4.5</b> Tipos de Dados e Dados F..</a></li>
<li><a class="menu-level-2" href="/pt/join"><b>4.6</b> Join</a></li>
<li><a class="menu-level-2" href="/pt/transformações-de-variáveis"><b>4.7</b> Transformações de Vari..</a></li>
<li><a class="menu-level-2" href="/pt/groupby_combine"><b>4.8</b> Groupby e Combine</a></li>
<li><a class="menu-level-2" href="/pt/df_performance"><b>4.9</b> Desempenho</a></li>
<li><a class="menu-level-1" href="/pt/DataVisualizationMakie"><b>5</b> Visualização de dados co..</a></li>
<li><a class="menu-level-2" href="/pt/cairomakie"><b>5.1</b> CairoMakie.jl</a></li>
<li><a class="menu-level-2" href="/pt/datavisMakie_attributes"><b>5.2</b> Atributos</a></li>
<li><a class="menu-level-2" href="/pt/themes"><b>5.3</b> Temas</a></li>
<li><a class="menu-level-2" href="/pt/usando-latexstrings.jl"><b>5.4</b> Usando LaTeXStrings.jl</a></li>
<li><a class="menu-level-2" href="/pt/makie_colors"><b>5.5</b> Cores e mapas de cores</a></li>
<li><a class="menu-level-2" href="/pt/makie_layouts"><b>5.6</b> Layouts</a></li>
<li><a class="menu-level-2" href="/pt/glmakie"><b>5.7</b> GLMakie.jl</a></li>
<li><a class="menu-level-1" href="/pt/appendix"><b>6</b> Apêndice</a></li>
<li><a class="menu-level-2" href="/pt/appendix_pkg"><b>6.1</b> Versões dos Pacotes</a></li>
<li><a class="menu-level-2" href="/pt/notation"><b>6.2</b> Formatação</a></li>
<li><a class="menu-level-1" href="/pt/referências"><b></b> Referências</a></li>
</div>
</aside>

<div class="books-content">
<h2 data-number="3.4" id="sec:standardlibrary"><span class="header-section-number">3.4</span> Biblioteca Padrão de Julia</h2>
<p>Julia tem uma <strong>biblioteca padrão rica</strong> que está disponível em <em>toda</em> instalação de Julia. Ao contrário de tudo o que vimos até agora, por exemplo, tipos, estruturas de dados e sistema de arquivos; você <strong>deve carregar módulos de biblioteca padrão em seu ambiente</strong> para usar um módulo ou função particular.</p>
<p>Isso é feito via <code>using</code> ou <code>import</code>. Neste livro, carregaremos o código via <code>using</code>:</p>
<pre class="julia"><code>using ModuleName</code></pre>
<p>Depois de fazer isso, você pode acessar todas as funções e tipos dentro do módulo chamado <code>ModuleName</code>.</p>
<h3 data-number="3.4.1" id="sec:dates"><span class="header-section-number">3.4.1</span> Datas</h3>
<p>Saber como lidar com datas e timestamps é importante na ciência de dados. Como dissemos na seção <em>Por que Julia?</em> (Section <a href="/pt/why_julia#sec:why_julia">2</a>), o <code>pandas</code> do Python usa seu próprio tipo de <code>datetime</code> para lidar com datas. O mesmo é verdade no tidyverse de R, no pacote <code>lubridate</code>, que também define o seu próprio tipo de <code>datetime</code> para lidar com datas. Em Julia, os pacotes não precisam escrever sua própria lógica de datas, porque Julia tem um módulo de datas em sua biblioteca padrão chamado <code>Dates</code>.</p>
<p>Para começar, vamos carregar o módulo <code>Dates</code>:</p>
<pre class="julia"><code>using Dates</code></pre>
<h4 data-number="3.4.1.1" id="sec:dates_types"><span class="header-section-number">3.4.1.1</span> Tipos <code>Date</code> e <code>DateTime</code></h4>
<p>O módulo de biblioteca padrão <code>Dates</code> tem <strong>dois tipos para trabalhar com datas</strong>:</p>
<ol type="1">
<li><code>Date</code>: representando o tempo em dias e</li>
<li><code>DateTime</code>: representando o tempo com precisão de milisegundos.</li>
</ol>
<p>Nós podemos construir <code>Date</code> e <code>DateTime</code> com o construtor padrão especificando um número inteiro para representar ano, mês, dia, horas e assim por diante:</p>
<pre class="language-julia"><code>Date(1987) # year</code></pre>
<pre class="output"><code>1987-01-01</code></pre>
<pre class="language-julia"><code>Date(1987, 9) # year, month</code></pre>
<pre class="output"><code>1987-09-01</code></pre>
<pre class="language-julia"><code>Date(1987, 9, 13) # year, month, day</code></pre>
<pre class="output"><code>1987-09-13</code></pre>
<pre class="language-julia"><code>DateTime(1987, 9, 13, 21) # year, month, day, hour</code></pre>
<pre class="output"><code>1987-09-13T21:00:00</code></pre>
<pre class="language-julia"><code>DateTime(1987, 9, 13, 21, 21) # year, month, day, hour, minute</code></pre>
<pre class="output"><code>1987-09-13T21:21:00</code></pre>
<p>Para os curiosos, 13 de setembro de 1987, 21:21 é a hora oficial do nascimento do primeiro autor, José.</p>
<p>Nós também podemos passar tipos “período” ou <code>Period</code> para o construtor padrão. <strong>Tipos <code>Period</code> são o equivalente-humano para a representação do tempo</strong> para o computador. <code>Dates</code> em Julia têm os seguintes subtipos abstratos de <code>Period</code>:</p>
<pre class="language-julia"><code>subtypes(Period)</code></pre>
<pre class="output"><code>DatePeriod</code></pre>
<pre class="output"><code>TimePeriod</code></pre>
<p>que se dividem nos seguintes tipos concretos, e eles são bastante autoexplicativos:</p>
<pre class="language-julia"><code>subtypes(DatePeriod)</code></pre>
<pre class="output"><code>Day</code></pre>
<pre class="output"><code>Month</code></pre>
<pre class="output"><code>Quarter</code></pre>
<pre class="output"><code>Week</code></pre>
<pre class="output"><code>Year</code></pre>
<pre class="language-julia"><code>subtypes(TimePeriod)</code></pre>
<pre class="output"><code>Hour</code></pre>
<pre class="output"><code>Microsecond</code></pre>
<pre class="output"><code>Millisecond</code></pre>
<pre class="output"><code>Minute</code></pre>
<pre class="output"><code>Nanosecond</code></pre>
<pre class="output"><code>Second</code></pre>
<p>Assim, poderíamos, alternativamente, construir a hora oficial de nascimento de José como:</p>
<pre class="language-julia"><code>DateTime(Year(1987), Month(9), Day(13), Hour(21), Minute(21))</code></pre>
<pre class="output"><code>1987-09-13T21:21:00</code></pre>
<h4 data-number="3.4.1.2" id="sec:dates_parsing"><span class="header-section-number">3.4.1.2</span> Parseando Datas</h4>
<p>Na maioria das vezes, não construiremos instâncias <code>Date</code> ou <code>DateTime</code> do zero. Na verdade, nós provavelmente <strong>parsearemos strings para transformá-las em tipos <code>Date</code> ou <code>DateTime</code></strong>.</p>
<p>Os construtores <code>Date</code> e <code>DateTime</code> podem ser alimentados com uma string e uma string de formato de data. Por exemplo, a string <code>"19870913"</code> representando 13 de setembro de 1987 pode ser parseada com:</p>
<pre class="language-julia"><code>Date(&quot;19870913&quot;, &quot;yyyymmdd&quot;)</code></pre>
<pre class="output"><code>1987-09-13</code></pre>
<p>Observe que o segundo argumento é uma representação em string do formato. Temos os primeiros quatro dígitos que representam o ano <code>y</code>, seguido por dois dígitos para o mês <code>m</code> e finalmente dois dígitos para dia <code>d</code>.</p>
<p>Também funciona para timestamps com <code>DateTime</code>:</p>
<pre class="language-julia"><code>DateTime(&quot;1987-09-13T21:21:00&quot;, &quot;yyyy-mm-ddTHH:MM:SS&quot;)</code></pre>
<pre class="output"><code>1987-09-13T21:21:00</code></pre>
<p>Você pode encontrar mais informações sobre como especificar diferentes formatos de data na <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.DateFormat">documentação <code>Dates</code>’ de Julia</a>. Não se preocupe se você tiver que revisitá-lo o tempo todo, nós mesmos fazemos isso ao trabalhar com datas e timestamps.</p>
<p>De acordo com a <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Constructors">documentação <code>Dates</code>’ de Julia</a>, usar o método <code>Date(date_string, format_string)</code> é satisfatório se ele for chamado apenas algumas vezes. Se houver muitas strings de data formatadas de forma semelhante para analisar, no entanto, é muito mais eficiente criar primeiro um tipo <code>DateFormat</code>, e, em seguida, o passar em vez de uma string de formato bruto. Então, nosso exemplo anterior se torna:</p>
<pre class="language-julia"><code>format = DateFormat(&quot;yyyymmdd&quot;)
Date(&quot;19870913&quot;, format)</code></pre>
<pre class="output"><code>1987-09-13</code></pre>
<p>Como alternativa, sem perda de desempenho, você pode usar o prefixo de string literal <code>dateformat"..."</code>:</p>
<pre class="language-julia"><code>Date(&quot;19870913&quot;, dateformat&quot;yyyymmdd&quot;)</code></pre>
<pre class="output"><code>1987-09-13</code></pre>
<h4 data-number="3.4.1.3" id="sec:dates_information"><span class="header-section-number">3.4.1.3</span> Extraindo Informações de Data</h4>
<p>É fácil <strong>extrair as informações desejadas dos objetos <code>Date</code> e<code>DateTime</code></strong>. Primeiro, vamos criar uma instância de uma data muito especial:</p>
<pre class="language-julia"><code>my_birthday = Date(&quot;1987-09-13&quot;)</code></pre>
<pre class="output"><code>1987-09-13</code></pre>
<p>Podemos extrair tudo o que quisermos de <code>my_birthday</code>:</p>
<pre class="language-julia"><code>year(my_birthday)</code></pre>
<pre class="output"><code>1987</code></pre>
<pre class="language-julia"><code>month(my_birthday)</code></pre>
<pre class="output"><code>9</code></pre>
<pre class="language-julia"><code>day(my_birthday)</code></pre>
<pre class="output"><code>13</code></pre>
<p>O módulo <code>Dates</code> de Julia também tem <strong>funções compostas que retornam uma tupla de valores</strong>:</p>
<pre class="language-julia"><code>yearmonth(my_birthday)</code></pre>
<pre class="output"><code>(1987, 9)</code></pre>
<pre class="language-julia"><code>monthday(my_birthday)</code></pre>
<pre class="output"><code>(9, 13)</code></pre>
<pre class="language-julia"><code>yearmonthday(my_birthday)</code></pre>
<pre class="output"><code>(1987, 9, 13)</code></pre>
<p>Também podemos ver o dia da semana e outras coisas úteis:</p>
<pre class="language-julia"><code>dayofweek(my_birthday)</code></pre>
<pre class="output"><code>7</code></pre>
<pre class="language-julia"><code>dayname(my_birthday)</code></pre>
<pre class="output"><code>Sunday</code></pre>
<pre class="language-julia"><code>dayofweekofmonth(my_birthday)</code></pre>
<pre class="output"><code>2</code></pre>
<p>Sim, José nasceu no segundo domingo de setembro.</p>
<blockquote>
<p><strong><em>OBSERVAÇÃO:</em></strong> Aqui está uma dica útil para recuperar apenas os dias de semana de instâncias de <code>Dates</code>. Use o <code>filter</code> no <code>dayofweek(your_date) &lt;= 5</code>. Para o dia útil, você pode verificar o pacote <a href="https://github.com/JuliaFinance/BusinessDays.jl"><code>BusinessDays.jl</code></a>.</p>
</blockquote>
<h4 data-number="3.4.1.4" id="sec:dates_operations"><span class="header-section-number">3.4.1.4</span> Operações de Data</h4>
<p>Podemos realizar <strong>operações</strong> em instâncias de <code>Dates</code>. Por exemplo, podemos adicionar dias a uma instância <code>Date</code> ou <code>DateTime</code>. Note que as <code>Dates</code> em Julia executará automaticamente os ajustes necessários para anos bissextos, e por meses com 30 ou 31 dias (isso é conhecido como aritmética <em>calendárica</em>.</p>
<pre class="language-julia"><code>my_birthday + Day(90)</code></pre>
<pre class="output"><code>1987-12-12</code></pre>
<p>Podemos adicionar quantas quisermos:</p>
<pre class="language-julia"><code>my_birthday + Day(90) + Month(2) + Year(1)</code></pre>
<pre class="output"><code>1989-02-11</code></pre>
<p>Caso você esteja se perguntando: “O que posso fazer com datas mesmo? O que está disponível?” então você pode usar <code>methodswith</code> para verificar. Mostramos apenas os primeiros 20 resultados aqui:</p>
<pre class="language-julia"><code>first(methodswith(Date), 20)</code></pre>
<pre class="output"><code>[1] show(io::IO, dt::Date) in Dates at /opt/hostedtoolcache/julia/1.7.1/x64/share/julia/stdlib/v1.7/Dates/src/io.jl:707
[2] show(io::IO, ::MIME{Symbol(&quot;text/plain&quot;)}, dt::Date) in Dates at /opt/hostedtoolcache/julia/1.7.1/x64/share/julia/stdlib/v1.7/Dates/src/io.jl:705
[3] DateTime(dt::Date, t::Time) in Dates at /opt/hostedtoolcache/julia/1.7.1/x64/share/julia/stdlib/v1.7/Dates/src/types.jl:403
[4] Day(dt::Date) in Dates at /opt/hostedtoolcache/julia/1.7.1/x64/share/julia/stdlib/v1.7/Dates/src/periods.jl:36
[5] Month(dt::Date) in Dates at /opt/hostedtoolcache/julia/1.7.1/x64/share/julia/stdlib/v1.7/Dates/src/periods.jl:36
[6] Quarter(dt::Date) in Dates at /opt/hostedtoolcache/julia/1.7.1/x64/share/julia/stdlib/v1.7/Dates/src/periods.jl:36
[7] Week(dt::Date) in Dates at /opt/hostedtoolcache/julia/1.7.1/x64/share/julia/stdlib/v1.7/Dates/src/periods.jl:36
[8] Year(dt::Date) in Dates at /opt/hostedtoolcache/julia/1.7.1/x64/share/julia/stdlib/v1.7/Dates/src/periods.jl:36
[9] firstdayofmonth(dt::Date) in Dates at /opt/hostedtoolcache/julia/1.7.1/x64/share/julia/stdlib/v1.7/Dates/src/adjusters.jl:84
[10] firstdayofquarter(dt::Date) in Dates at /opt/hostedtoolcache/julia/1.7.1/x64/share/julia/stdlib/v1.7/Dates/src/adjusters.jl:157
[11] firstdayofweek(dt::Date) in Dates at /opt/hostedtoolcache/julia/1.7.1/x64/share/julia/stdlib/v1.7/Dates/src/adjusters.jl:52
[12] firstdayofyear(dt::Date) in Dates at /opt/hostedtoolcache/julia/1.7.1/x64/share/julia/stdlib/v1.7/Dates/src/adjusters.jl:119
[13] lastdayofmonth(dt::Date) in Dates at /opt/hostedtoolcache/julia/1.7.1/x64/share/julia/stdlib/v1.7/Dates/src/adjusters.jl:100
[14] lastdayofquarter(dt::Date) in Dates at /opt/hostedtoolcache/julia/1.7.1/x64/share/julia/stdlib/v1.7/Dates/src/adjusters.jl:180
[15] lastdayofweek(dt::Date) in Dates at /opt/hostedtoolcache/julia/1.7.1/x64/share/julia/stdlib/v1.7/Dates/src/adjusters.jl:68
[16] lastdayofyear(dt::Date) in Dates at /opt/hostedtoolcache/julia/1.7.1/x64/share/julia/stdlib/v1.7/Dates/src/adjusters.jl:135
[17] +(dt::Date, t::Time) in Dates at /opt/hostedtoolcache/julia/1.7.1/x64/share/julia/stdlib/v1.7/Dates/src/arithmetic.jl:19
[18] +(dt::Date, y::Year) in Dates at /opt/hostedtoolcache/julia/1.7.1/x64/share/julia/stdlib/v1.7/Dates/src/arithmetic.jl:27
[19] +(dt::Date, z::Month) in Dates at /opt/hostedtoolcache/julia/1.7.1/x64/share/julia/stdlib/v1.7/Dates/src/arithmetic.jl:54
[20] +(x::Date, y::Quarter) in Dates at /opt/hostedtoolcache/julia/1.7.1/x64/share/julia/stdlib/v1.7/Dates/src/arithmetic.jl:73</code></pre>
<p>A partir disso, podemos concluir que também podemos usar o operador de sinal de mais <code>+</code> e menos <code>-</code>. Vamos ver quantos anos o José tem, em dias:</p>
<pre class="language-julia"><code>today() - my_birthday</code></pre>
<pre class="output"><code>12556 days</code></pre>
<p>A <strong>duração padrão</strong> de tipos de <code>Date</code> é uma instância de <code>Day</code>. Para o <code>DateTime</code>, a duração padrão é uma instância de <code>Millisecond</code>:</p>
<pre class="language-julia"><code>DateTime(today()) - DateTime(my_birthday)</code></pre>
<pre class="output"><code>1084838400000 milliseconds</code></pre>
<h4 data-number="3.4.1.5" id="sec:dates_intervals"><span class="header-section-number">3.4.1.5</span> Intervalos de Data</h4>
<p>Uma coisa boa sobre o módulo <code>Dates</code> é que também podemos construir facilmente <strong>intervalos de data e hora</strong>. Julia é inteligente o suficiente para não ter que definir todos os tipos de intervalo e operações que abordamos em Section <a href="/pt/data_structures#sec:ranges">3.2.5</a>. Ela apenas estende as funções e operações definidas para range para os tipos <code>Date</code>. Isso é conhecido como despacho múltiplo e já abordamos isso em <em>Por que Julia?</em> (Section <a href="/pt/why_julia#sec:why_julia">2</a>).</p>
<p>Por exemplo, suponha que você deseja criar um intervalo de tipo <code>Day</code>. Isso é fácil de fazer com o operador dois-pontos <code>:</code>:</p>
<pre class="language-julia"><code>Date(&quot;2021-01-01&quot;):Day(1):Date(&quot;2021-01-07&quot;)</code></pre>
<pre class="output"><code>2021-01-01</code></pre>
<pre class="output"><code>2021-01-02</code></pre>
<pre class="output"><code>2021-01-03</code></pre>
<pre class="output"><code>2021-01-04</code></pre>
<pre class="output"><code>2021-01-05</code></pre>
<pre class="output"><code>2021-01-06</code></pre>
<pre class="output"><code>2021-01-07</code></pre>
<p>Não há nada de especial em usar <code>Day(1)</code> como o intervalo, podemos <strong>usar qualquer tipo <code>Period</code></strong> como intervalo. Por exemplo, usando 3 dias como intervalo:</p>
<pre class="language-julia"><code>Date(&quot;2021-01-01&quot;):Day(3):Date(&quot;2021-01-07&quot;)</code></pre>
<pre class="output"><code>2021-01-01</code></pre>
<pre class="output"><code>2021-01-04</code></pre>
<pre class="output"><code>2021-01-07</code></pre>
<p>Ou mesmo meses:</p>
<pre class="language-julia"><code>Date(&quot;2021-01-01&quot;):Month(1):Date(&quot;2021-03-01&quot;)</code></pre>
<pre class="output"><code>2021-01-01</code></pre>
<pre class="output"><code>2021-02-01</code></pre>
<pre class="output"><code>2021-03-01</code></pre>
<p>Perceba que o <strong>tipo deste intervalo é um <code>StepRange</code> com o <code>Date</code> e um tipo concreto <code>Period</code></strong> que usamos como intervalo dentro do operador <code>:</code>:</p>
<pre class="language-julia"><code>date_interval = Date(&quot;2021-01-01&quot;):Month(1):Date(&quot;2021-03-01&quot;)
typeof(date_interval)</code></pre>
<pre class="output"><code>StepRange{Date, Month}</code></pre>
<p>Podemos converter isso para um <strong>vetor</strong> com a função <code>collect</code>:</p>
<pre class="language-julia"><code>collected_date_interval = collect(date_interval)</code></pre>
<pre class="output"><code>2021-01-01</code></pre>
<pre class="output"><code>2021-02-01</code></pre>
<pre class="output"><code>2021-03-01</code></pre>
<p>E teremos todas as <strong>funcionalidades de array disponíveis</strong>, como, por exemplo, indexação:</p>
<pre class="language-julia"><code>collected_date_interval[end]</code></pre>
<pre class="output"><code>2021-03-01</code></pre>
<p>Também podemos fazer <strong>broadcast de operações de data</strong> em um vetor de <code>Date</code>s:</p>
<pre class="language-julia"><code>collected_date_interval .+ Day(10)</code></pre>
<pre class="output"><code>2021-01-11</code></pre>
<pre class="output"><code>2021-02-11</code></pre>
<pre class="output"><code>2021-03-11</code></pre>
<p>Da mesma forma, esses exemplos funcionam para tipos <code>DateTime</code> também.</p>
<h3 data-number="3.4.2" id="sec:random"><span class="header-section-number">3.4.2</span> Números Aleatórios</h3>
<p>Outro módulo importante na biblioteca padrão de Julia é o módulo <code>Random</code>. Este módulo lida com <strong>geração de números aleatórios</strong>. <code>Random</code> é uma biblioteca rica e, se você está interessado, deve consultar a <a href="https://docs.julialang.org/en/v1/stdlib/Random/">documentação <code>Random</code> de Julia</a>. Vamos cobrir <em>somente</em> três funções: <code>rand</code>, <code>randn</code> e <code>seed!</code>.</p>
<p>Para começar, primeiro carregamos o módulo <code>Random</code>. Como sabemos exatamente o que queremos carregar, podemos também carregar explicitamente os métodos que queremos usar:</p>
<pre class="julia"><code>using Random: rand, randn, seed!</code></pre>
<p>Nós temos <strong>duas funções principais que geram números aleatórios</strong>:</p>
<ul>
<li><code>rand</code>: faz a amostragem de um <strong>elemento aleatório</strong> de uma estrutura ou tipo de dados.</li>
<li><code>randn</code>: gera um número aleatório que segue uma <strong>distribuição normal padrão</strong> (média 0 e desvio padrão 1) de um tipo específico.</li>
</ul>
<blockquote>
<p><strong><em>OBSERVAÇÃO:</em></strong> Observe que essas duas funções já estão no módulo <code>Base</code> de Julia. Então, você não precisa importar <code>Random</code> se estiver planejando usá-los.</p>
</blockquote>
<h4 data-number="3.4.2.1" id="sec:random_rand"><span class="header-section-number">3.4.2.1</span> <code>rand</code></h4>
<p>Por padrão, se você chamar <code>rand</code> sem argumentos, ele retornará um <code>Float64</code> no intervalo <span class="math inline">\([0, 1)\)</span>, o que significa no intervalo compreendido entre os limites 0 inclusivo e 1 exclusivo:</p>
<pre class="language-julia"><code>rand()</code></pre>
<pre class="output"><code>0.9254222481238623</code></pre>
<p>Você pode modificar argumentos <code>rand</code> de várias maneiras. Por exemplo, suponha que você queira mais de 1 número aleatório:</p>
<pre class="language-julia"><code>rand(3)</code></pre>
<pre class="output"><code>[0.7029244663701457, 0.6589159413712516, 0.7637832268559482]</code></pre>
<p>Ou você quer um intervalo diferente:</p>
<pre class="language-julia"><code>rand(1.0:10.0)</code></pre>
<pre class="output"><code>9.0</code></pre>
<p>Você também pode especificar um tamanho de incremento diferente dentro do intervalo e um tipo diferente. Aqui estamos usando números sem ponto <code>.</code> então Julia irá interpretá-los como <code>Int64</code>:</p>
<pre class="language-julia"><code>rand(2:2:20)</code></pre>
<pre class="output"><code>20</code></pre>
<p>Você também pode misturar e combinar argumentos:</p>
<pre class="language-julia"><code>rand(2:2:20, 3)</code></pre>
<pre class="output"><code>[14, 20, 20]</code></pre>
<p><code>rand</code> também aceita uma coleção de elementos como, por exemplo, uma tupla:</p>
<pre class="language-julia"><code>rand((42, &quot;Julia&quot;, 3.14))</code></pre>
<pre class="output"><code>42</code></pre>
<p>E também arrays:</p>
<pre class="language-julia"><code>rand([1, 2, 3])</code></pre>
<pre class="output"><code>2</code></pre>
<p><code>Dict</code>s:</p>
<pre class="language-julia"><code>rand(Dict(:one =&gt; 1, :two =&gt; 2))</code></pre>
<pre class="output"><code>:two =&gt; 2</code></pre>
<p>Para terminar todas as opções de argumentos <code>rand</code>, você pode especificar as dimensões de número aleatório desejadas em uma tupla. Se você fizer isso, o tipo retornado será uma array. Por exemplo, aqui uma matriz 2x2 de números <code>Float64</code> entre 1.0 e 3.0:</p>
<pre class="language-julia"><code>rand(1.0:3.0, (2, 2))</code></pre>
<pre class="output"><code>2×2 Matrix{Float64}:
 1.0  2.0
 2.0  3.0</code></pre>
<h4 data-number="3.4.2.2" id="sec:random_randn"><span class="header-section-number">3.4.2.2</span> <code>randn</code></h4>
<p><code>randn</code> segue o mesmo princípio geral de <code>rand</code>, mas agora ele só retorna números gerados a partir da <strong>distribuição normal padrão</strong>. A distribuição normal padrão é a distribuição normal com média 0 e desvio padrão 1. O tipo padrão é <code>Float64</code> e só permite subtipos de <code>AbstractFloat</code> ou <code>Complex</code>:</p>
<pre class="language-julia"><code>randn()</code></pre>
<pre class="output"><code>0.513588244203061</code></pre>
<p>Só podemos especificar o tamanho:</p>
<pre class="language-julia"><code>randn((2, 2))</code></pre>
<pre class="output"><code>2×2 Matrix{Float64}:
  0.147726   0.33378
 -0.166356  -0.268258</code></pre>
<h4 data-number="3.4.2.3" id="sec:random_seed"><span class="header-section-number">3.4.2.3</span> <code>seed!</code></h4>
<p>Para terminar a visão geral de <code>Random</code>, vamos falar sobre <strong>reprodutibilidade</strong>. Muitas vezes, queremos fazer algo <strong>replicável</strong>. Ou seja, queremos que o gerador de números aleatórios gere a <strong>mesma sequência aleatória de números</strong>. Podemos fazer isso com a função <code>seed!</code>:</p>
<pre class="language-julia"><code>seed!(123)
rand(3)</code></pre>
<pre class="output"><code>[0.521213795535383, 0.5868067574533484, 0.8908786980927811]</code></pre>
<pre class="language-julia"><code>seed!(123)
rand(3)</code></pre>
<pre class="output"><code>[0.521213795535383, 0.5868067574533484, 0.8908786980927811]</code></pre>
<p>A fim de evitar a repetição tediosa e ineficiente de <code>seed!</code> em todo lugar, podemos definir uma instância de <code>seed!</code> e passá-la como o primeiro argumento de <strong><code>rand</code> ou <code>randn</code></strong>.</p>
<pre class="language-julia"><code>my_seed = seed!(123)</code></pre>
<pre class="output"><code>Random.TaskLocalRNG()</code></pre>
<pre class="language-julia"><code>rand(my_seed, 3)</code></pre>
<pre class="output"><code>[0.19090669902576285, 0.5256623915420473, 0.3905882754313441]</code></pre>
<pre class="language-julia"><code>rand(my_seed, 3)</code></pre>
<pre class="output"><code>[0.19090669902576285, 0.5256623915420473, 0.3905882754313441]</code></pre>
<blockquote>
<p><strong><em>OBSERVAÇÃO:</em></strong> Se você quiser que seu código seja reproduzível, basta chamar <code>seed!</code> no começo do seu script. Isso cuidará da reprodutibilidade sequencial das operações <code>Random</code>. Não há necessidade de usá-la dentro de todo <code>rand</code> e <code>randn</code>.</p>
</blockquote>
<h3 data-number="3.4.3" id="sec:downloads"><span class="header-section-number">3.4.3</span> Downloads</h3>
<p>Uma última coisa da biblioteca padrão de Julia para cobrirmos é o <strong>módulo <code>Download</code></strong>. Será muito breve porque iremos cobrir apenas uma única função chamada <code>download</code>.</p>
<p>Suponha que você queira <strong>fazer o download de um arquivo da internet para o seu armazenamento local</strong>. Você pode fazer isso com a função <code>download</code>. O primeiro e único argumento obrigatório é o url do arquivo. Você também pode especificar como um segundo argumento o caminho de saída desejado para o arquivo baixado (não se esqueça das práticas recomendadas do sistema de arquivos!). Se você não especificar um segundo argumento, Julia irá, por padrão, criar um arquivo temporário com a função <code>tempfile</code>.</p>
<p>Vamos carregar o método <code>download</code>:</p>
<pre class="julia"><code>using Download: download</code></pre>
<p>Por exemplo, vamos baixar nosso arquivo <code>Project.toml</code> do <a href="https://github.com/JuliaDataScience/JuliaDataScience">repositório GitHub <code>JuliaDataScience</code></a>. Observe que a função <code>download</code> não é exportada pelo módulo <code>Downloads</code>, então temos que usar a sintaxe <code>Module.function</code>. Por padrão, ele retorna uma string que contém o caminho do arquivo para o arquivo baixado:</p>
<pre class="language-julia"><code>url = &quot;https://raw.githubusercontent.com/JuliaDataScience/JuliaDataScience/main/Project.toml&quot;

my_file = Downloads.download(url) # tempfile() being created</code></pre>
<pre class="output"><code>/tmp/jl_ZKhQ5U</code></pre>
<p>Com <code>readlines</code>, nós podemos observar as primeiras 4 linhas do arquivo que baixamos:</p>
<pre class="language-julia"><code>readlines(my_file)[1:4]</code></pre>
<pre class="output"><code>4-element Vector{String}:
 &quot;name = \&quot;JDS\&quot;&quot;
 &quot;uuid = \&quot;6c596d62-2771-44f8-8373-3ec4b616ee9d\&quot;&quot;
 &quot;authors = [\&quot;Jose Storopoli\&quot;, \&quot;Rik Huijzer\&quot;, \&quot;Lazaro Alonso\&quot;]&quot;
 &quot;version = \&quot;0.1.0\&quot;&quot;</code></pre>
<blockquote>
<p><strong><em>OBSERVAÇÃO:</em></strong> Para interações HTTP mais complexas, como interação com APIs da web, consulte o pacote <a href="https://github.com/JuliaWeb/HTTP.jl"><code>HTTP.jl</code></a>.</p>
</blockquote>


<div class="bottom-nav">
    <p id="nav-prev" style="text-align: left;">
        <a class="menu-level-2" href="/pt/filesystem"><b>3.3</b> Sistema de Arquivos</a> <kbd>←</kbd>
        <span id="nav-next" style="float: right;">
            <kbd>→</kbd> <a class="menu-level-1" href="/pt/dataframes"><b>4</b> DataFrames.jl</a>
        </span>
    </p>
</div>


<div class="license">
    <br/>
  <br/>
  <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
    Jose Storopoli, Rik Huijzer, Lazaro Alonso
</div>
</div>
</div>
</body>
</html>