<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Jose Storopoli" />
  <meta name="author" content="Rik Huijzer" />
  <meta name="author" content="Lazaro Alonso" />
  <title>Sintaxe da linguagem - Julia Data Science</title>
  <link rel="shortcut icon" type="image/png" href="/pt/favicon.png"/>
  <link rel="stylesheet" href="/pt/style.css"/>
    <script src="/pt/mousetrap.min.js"></script>
    <style>
  @font-face {
    font-family: JuliaMono-Regular;
    src: url("/pt/JuliaMono-Regular.woff2");
  }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <link rel="stylesheet" href="/pt/github.min.css">
<script src="/pt/highlight.min.js"></script>
<script src="/pt/julia.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', (event) => {
    document.querySelectorAll('pre').forEach((el) => {
        hljs.highlightElement(el);
    });
});
</script>
 
</head>
<body>
<script>
function click_next() {
  var next = document.getElementById('nav-next');
  next.firstElementChild.nextElementSibling.click();
}
function click_prev() {
  var prev = document.getElementById('nav-prev');
  prev.firstElementChild.click();
}
Mousetrap.bind('right', click_next);
Mousetrap.bind('h', click_prev);
Mousetrap.bind('left', click_prev);
Mousetrap.bind('l', click_next);
</script>

<div class="books-container">
<aside class="books-menu">
<input type="checkbox" id="menu">
<label for="menu">☰</label>
<div class="books-title">
<a href="/pt/">Julia Data Science</a>
</div><br />
<span class="books-subtitle">

</span>
<div class="books-menu-content">
<li><a class="menu-level-1" href="/pt/preface"><b>1</b> Prefácio</a></li>
<li><a class="menu-level-2" href="/pt/why_data_science"><b>1.1</b> O que é Ciência de Dad..</a></li>
<li><a class="menu-level-2" href="/pt/engineering"><b>1.2</b> Engenharia de software</a></li>
<li><a class="menu-level-2" href="/pt/agradecimentos"><b>1.3</b> Agradecimentos</a></li>
<li><a class="menu-level-1" href="/pt/why_julia"><b>2</b> Por que Julia?</a></li>
<li><a class="menu-level-2" href="/pt/non-programmers"><b>2.1</b> Para os que nunca progra..</a></li>
<li><a class="menu-level-2" href="/pt/programmers"><b>2.2</b> Para programadores</a></li>
<li><a class="menu-level-2" href="/pt/julia_accomplish"><b>2.3</b> O que Julia pretende alc..</a></li>
<li><a class="menu-level-2" href="/pt/julia_wild"><b>2.4</b> Julia Por Aí</a></li>
<li><a class="menu-level-1" href="/pt/julia_basics"><b>3</b> Básico de Julia</a></li>
<li><a class="menu-level-2" href="/pt/syntax"><b>3.1</b> Sintaxe da linguagem</a></li>
<li><a class="menu-level-2" href="/pt/data_structures"><b>3.2</b> Estruturas Nativas de Da..</a></li>
<li><a class="menu-level-2" href="/pt/filesystem"><b>3.3</b> Sistema de Arquivos</a></li>
<li><a class="menu-level-2" href="/pt/standardlibrary"><b>3.4</b> Biblioteca Padrão de Ju..</a></li>
<li><a class="menu-level-1" href="/pt/dataframes"><b>4</b> DataFrames.jl</a></li>
<li><a class="menu-level-2" href="/pt/load_save"><b>4.1</b> Carregar e salvar arquiv..</a></li>
<li><a class="menu-level-2" href="/pt/indexação-e-sumarização"><b>4.2</b> Indexação e Sumarização</a></li>
<li><a class="menu-level-2" href="/pt/filter_subset"><b>4.3</b> Filtro e Subconjunto</a></li>
<li><a class="menu-level-2" href="/pt/select"><b>4.4</b> Select</a></li>
<li><a class="menu-level-2" href="/pt/missing_data"><b>4.5</b> Tipos de Dados e Dados F..</a></li>
<li><a class="menu-level-2" href="/pt/join"><b>4.6</b> Join</a></li>
<li><a class="menu-level-2" href="/pt/transformações-de-variáveis"><b>4.7</b> Transformações de Vari..</a></li>
<li><a class="menu-level-2" href="/pt/groupby_combine"><b>4.8</b> Groupby e Combine</a></li>
<li><a class="menu-level-2" href="/pt/df_performance"><b>4.9</b> Desempenho</a></li>
<li><a class="menu-level-1" href="/pt/DataVisualizationMakie"><b>5</b> Visualização de dados co..</a></li>
<li><a class="menu-level-2" href="/pt/cairomakie"><b>5.1</b> CairoMakie.jl</a></li>
<li><a class="menu-level-2" href="/pt/datavisMakie_attributes"><b>5.2</b> Atributos</a></li>
<li><a class="menu-level-2" href="/pt/themes"><b>5.3</b> Temas</a></li>
<li><a class="menu-level-2" href="/pt/usando-latexstrings.jl"><b>5.4</b> Usando LaTeXStrings.jl</a></li>
<li><a class="menu-level-2" href="/pt/makie_colors"><b>5.5</b> Cores e mapas de cores</a></li>
<li><a class="menu-level-2" href="/pt/makie_layouts"><b>5.6</b> Layouts</a></li>
<li><a class="menu-level-2" href="/pt/glmakie"><b>5.7</b> GLMakie.jl</a></li>
<li><a class="menu-level-1" href="/pt/appendix"><b>6</b> Apêndice</a></li>
<li><a class="menu-level-2" href="/pt/appendix_pkg"><b>6.1</b> Versões dos Pacotes</a></li>
<li><a class="menu-level-2" href="/pt/notation"><b>6.2</b> Formatação</a></li>
<li><a class="menu-level-1" href="/pt/referências"><b></b> Referências</a></li>
</div>
</aside>

<div class="books-content">
<h2 data-number="3.1" id="sec:syntax"><span class="header-section-number">3.1</span> Sintaxe da linguagem</h2>
<p>Julia é uma <strong>linguagem de tipagem dinâmica</strong> com um compilador just-in-time. Isso significa que você não precisa compilar seu programa antes de executá-lo, como precisaria fazer com C++ ou FORTRAN. Em vez disso, Julia pegará seu código, adivinhará os tipos quando necessário e compilará partes do código antes de executá-lo. Além disso, você não precisa especificar explicitamente cada tipo. Julia vai inferir os tipos para você na hora.</p>
<p>As principais diferenças entre Julia e outras linguagens dinâmicas como R e Python são: Primeiro, Julia <strong>permite ao usuário especificar declarações de tipo</strong>. Você já viu algumas declarações de tipo em <em>Por que Julia?</em> (Section <a href="/pt/why_julia#sec:why_julia">2</a>): eles são aqueles dois pontos duplos <code>::</code> que às vezes vem depois das variáveis. No entanto, se você não quiser especificar o tipo de suas variáveis ou funções, Julia terá o prazer de inferir (adivinhar) para você.</p>
<p>Em segundo lugar, Julia permite que os usuários definam o comportamento da função de acordo com combinações diversas de tipos de argumento por meio do despacho múltiplo. Também falamos sobre despacho múltiplo em Section <a href="/pt/julia_accomplish#sec:julia_accomplish">2.3</a>. Por meio do despacho múltiplo, nós definimos um comportamento diferente de uma função para um determinado tipo quando escrevemos uma nova função com o mesmo nome da função anterior, mas cuja assinatura contém a especifcação deste tipo em seus argumentos.</p>
<h3 data-number="3.1.1" id="sec:variable"><span class="header-section-number">3.1.1</span> Variáveis</h3>
<p>As variáveis são valores que você diz ao computador para armazenar com um nome específico, para que você possa recuperar ou alterar seu valor posteriormente. Julia tem diversos tipos de variáveis, mas, em ciência de dados, usamos principalmente:</p>
<ul>
<li>Números inteiros: <code>Int64</code></li>
<li>Números reais: <code>Float64</code></li>
<li>Booleanas: <code>Bool</code></li>
<li>Strings: <code>String</code></li>
</ul>
<p>Inteiros e números reais são armazenados usando 64 bits por padrão, é por isso que eles têm o sufixo <code>64</code> no nome do tipo. Se você precisar de mais ou menos precisão, existem os tipos <code>Int8</code> ou <code>Int128</code>, por exemplo, nos quais um maior número significa uma maior precisão. Na maioria das vezes, isso não será um problema, então você pode simplesmente seguir os padrões.</p>
<p>Criamos novas variáveis escrevendo o nome da variável à esquerda e seu valor à direita, e no meio usamos o operador de atribuição <code>=</code>. Por exemplo:</p>
<pre class="language-julia"><code>name = &quot;Julia&quot;
age = 9</code></pre>
<pre class="output"><code>9</code></pre>
<p>Observe que a saída de retorno da última instrução (<code>idade</code>) foi impressa no console. Aqui, estamos definindo duas novas variáveis: <code>nome</code> e <code>idade</code>. Podemos recuperar seus valores digitando os nomes dados na atribuição:</p>
<pre class="language-julia"><code>name</code></pre>
<pre class="output"><code>Julia</code></pre>
<p>Se quiser definir novos valores para uma variável existente, você pode repetir os passos realizados durante a atribuição. Observe que Julia agora substituirá o valor anterior pelo novo. Suponho que o aniversário de Julia já passou e agora fez 10 anos:</p>
<pre class="language-julia"><code>age = 10</code></pre>
<pre class="output"><code>10</code></pre>
<p>Podemos fazer o mesmo com <code>name</code>. Suponha que Julia tenha ganho alguns títulos devido à sua velocidade incrível. Mudaríamos a variável <code>name</code> para o novo valor:</p>
<pre class="language-julia"><code>name = &quot;Julia Rapidus&quot;</code></pre>
<pre class="output"><code>Julia Rapidus</code></pre>
<p>Também podemos fazer operações em variáveis como adição ou divisão. Vamos ver quantos anos Julia tem, em meses, multiplicando <code>age</code> por 12:</p>
<pre class="language-julia"><code>12 * age</code></pre>
<pre class="output"><code>120</code></pre>
<p>Podemos inspecionar os tipos das variáveis usando a função <code>typeof</code>:</p>
<pre class="language-julia"><code>typeof(age)</code></pre>
<pre class="output"><code>Int64</code></pre>
<p>A próxima pergunta então se torna: “O que mais posso fazer com os inteiros?” Há uma função boa e útil, <code>methodswith</code> que expõe todas as funções disponíveis, junto com sua assinatura, para um certo tipo. Aqui, vamos restringir a saída às primeiras 5 linhas:</p>
<pre class="language-julia"><code>first(methodswith(Int64), 5)</code></pre>
<pre class="output"><code>[1] logmvbeta(p::Int64, a::T, b::T) where T&lt;:Real in StatsFuns at /home/runner/.julia/packages/StatsFuns/5v7Lq/src/misc.jl:22
[2] logmvbeta(p::Int64, a::Real, b::Real) in StatsFuns at /home/runner/.julia/packages/StatsFuns/5v7Lq/src/misc.jl:23
[3] logmvgamma(p::Int64, a::Real) in StatsFuns at /home/runner/.julia/packages/StatsFuns/5v7Lq/src/misc.jl:8
[4] read(t::HTTP.ConnectionPool.Transaction, nb::Int64) in HTTP.ConnectionPool at /home/runner/.julia/packages/HTTP/aTjcj/src/ConnectionPool.jl:232
[5] write(ctx::MbedTLS.MD, i::Union{Float16, Float32, Float64, Int128, Int16, Int32, Int64, UInt128, UInt16, UInt32, UInt64}) in MbedTLS at /home/runner/.julia/packages/MbedTLS/4YY6E/src/md.jl:140</code></pre>
<h3 data-number="3.1.2" id="sec:struct"><span class="header-section-number">3.1.2</span> Tipos definidos pelo usuário</h3>
<p>Ter apenas variáveis à disposição, sem qualquer forma de hierarquia ou relacionamento não é o ideal. Em Julia, podemos definir essa espécie de dado estruturado com um <code>struct</code> (também conhecido como tipo composto). Dentro de cada <code>struct</code>, você pode especificar um conjunto de campos <code>field</code>s. Eles diferem dos tipos primitivos (por exemplo, inteiro e flutuantes) que já são definidos por padrão dentro do núcleo da linguagem Julia. Já que a maioria dos <code>struct</code> são definidos pelo usuário, eles são conhecidos como tipos definidos pelo usuário.</p>
<p>Por exemplo, vamos criar um <code>struct</code> para representar linguagens de programação científica em código aberto. Também definiremos um conjunto de campos junto com os tipos correspondentes dentro do <code>struct</code>:</p>
<pre class="language-julia"><code>struct Language
    name::String
    title::String
    year_of_birth::Int64
    fast::Bool
end</code></pre>
<p>Para inspecionar os nomes dos campos, você pode usar o <code>fieldnames</code> e passar o <code>struct</code> desejado como argumento:</p>
<pre class="language-julia"><code>fieldnames(Language)</code></pre>
<pre class="output"><code>(:name, :title, :year_of_birth, :fast)</code></pre>
<p>Para usar os <code>struct</code>, devemos instanciar instâncias individuais (ou “objetos”), cada um com seus próprios valores específicos para os campos definidos dentro do <code>struct</code>. Vamos instanciar duas instâncias, uma para Julia e outra para Python:</p>
<pre class="language-julia"><code>julia = Language(&quot;Julia&quot;, &quot;Rapidus&quot;, 2012, true)
python = Language(&quot;Python&quot;, &quot;Letargicus&quot;, 1991, false)</code></pre>
<pre class="output"><code>Language(&quot;Python&quot;, &quot;Letargicus&quot;, 1991, false)</code></pre>
<p>Algo importante de se notar com os <code>struct</code> é que não podemos alterar seus valores uma vez que são instanciados. Podemos resolver isso com <code>mutable struct</code>. Além disso, observe que objetos mutáveis geralmente serão mais lentos e mais propensos a erros. Sempre que possível, faça com que tudo seja <em>imutável</em>. Vamos criar uma <code>mutable struct</code>.</p>
<pre class="language-julia"><code>mutable struct MutableLanguage
    name::String
    title::String
    year_of_birth::Int64
    fast::Bool
end

julia_mutable = MutableLanguage(&quot;Julia&quot;, &quot;Rapidus&quot;, 2012, true)</code></pre>
<pre class="output"><code>MutableLanguage(&quot;Julia&quot;, &quot;Rapidus&quot;, 2012, true)</code></pre>
<p>Suponha que queremos mudar o campo título do objeto <code>julia_mutable</code>. Agora podemos fazer isso já que <code>julia_mutable</code> é um <code>mutable struct</code> instanciado:</p>
<pre class="language-julia"><code>julia_mutable.title = &quot;Python Obliteratus&quot;

julia_mutable</code></pre>
<pre class="output"><code>MutableLanguage(&quot;Julia&quot;, &quot;Python Obliteratus&quot;, 2012, true)</code></pre>
<h3 data-number="3.1.3" id="operadores-booleanos-e-comparações-numéricas"><span class="header-section-number">3.1.3</span> Operadores booleanos e comparações numéricas</h3>
<p>Agora que cobrimos os tipos, podemos passar para os operadores booleanos e a comparação numérica.</p>
<p>Nós temos três operadores booleanos em Julia:</p>
<ul>
<li><code>!</code>: <strong>NOT</strong></li>
<li><code>&amp;&amp;</code>: <strong>AND</strong></li>
<li><code>||</code>: <strong>OR</strong></li>
</ul>
<p>Aqui estão exemplos com alguns deles:</p>
<pre class="language-julia"><code>!true</code></pre>
<pre class="output"><code>false</code></pre>
<pre class="language-julia"><code>(false &amp;&amp; true) || (!false)</code></pre>
<pre class="output"><code>true</code></pre>
<pre class="language-julia"><code>(6 isa Int64) &amp;&amp; (6 isa Real)</code></pre>
<pre class="output"><code>true</code></pre>
<p>Com relação à comparação numérica, Julia tem três tipos principais de comparações:</p>
<ol type="1">
<li><strong>Igualdade</strong>: ou algo é <em>igual</em> ou <em>não igual</em> em relação a outro
<ul>
<li>== “igual”</li>
<li>!= ou ≠ “não igual”</li>
</ul></li>
<li><strong>Menor que</strong>: ou algo é <em>menor que</em> ou <em>menor ou igual a</em>
<ul>
<li>&lt; “menor que”</li>
<li>&lt;= ou ≤ “menor ou igual a”</li>
</ul></li>
<li><strong>Maior que</strong>: ou algo é <em>maior que</em> ou <em>maior ou igual a</em>
<ul>
<li>&gt; “maior que”</li>
<li>&gt;= ou ≥ “maior ou igual a”</li>
</ul></li>
</ol>
<p>Aqui temos alguns exemplos:</p>
<pre class="language-julia"><code>1 == 1</code></pre>
<pre class="output"><code>true</code></pre>
<pre class="language-julia"><code>1 &gt;= 10</code></pre>
<pre class="output"><code>false</code></pre>
<p>As comparações funcionam até mesmo entre tipos diferentes:</p>
<pre class="language-julia"><code>1 == 1.0</code></pre>
<pre class="output"><code>true</code></pre>
<p>Também podemos misturar e combinar operadores booleanos com comparações numéricas:</p>
<pre class="language-julia"><code>(1 != 10) || (3.14 &lt;= 2.71)</code></pre>
<pre class="output"><code>true</code></pre>
<h3 data-number="3.1.4" id="sec:function"><span class="header-section-number">3.1.4</span> Funções</h3>
<p>Agora que já sabemos como definir variáveis e tipos personalizados como <code>struct</code>, vamos voltar nossa atenção para as <strong>funções</strong>. Em Julia, uma função <strong>mapeia os valores de seus argumentos para um ou mais valores de retorno</strong>. A sintaxe básica é assim:</p>
<pre class="julia"><code>function function_name(arg1, arg2)
    result = stuff with the arg1 and arg2
    return result
end</code></pre>
<p>A declaração de funções começa com a palavra-chave <code>function</code> seguida do nome da função. Então, entre parênteses <code>()</code>, nós definimos os argumentos separados por uma vírgula <code>,</code>. Dentro da função, especificamos o que queremos que Julia faça com os parâmetros que fornecemos. Todas as variáveis que definimos dentro de uma função são excluídas após o retorno da função. Isso é bom porque é como se realizasse uma limpeza automática. Depois que todas as operações no corpo da função forem concluídas, instruímos Julia a retornar o resultado com o comando <code>return</code>. Por fim, informamos a Julia que a definição da função terminou com a palavra-chave <code>end</code>.</p>
<p>Existe também a maneira compacta de definição de funções por meio da <strong>forma de atribuição</strong>:</p>
<pre class="julia"><code>f_name(arg1, arg2) = stuff with the arg1 and arg2</code></pre>
<p>É a <strong>mesma função</strong> que antes, mas definida de uma forma diferente, mais compacta. Como regra geral, quando seu código pode caber facilmente em uma linha de até 92 caracteres, a forma compacta é adequada. Caso contrário, basta usar o formato mais longo com a palavra-chave <code>function</code>. Vamos mergulhar em alguns exemplos.</p>
<h4 data-number="3.1.4.1" id="sec:function_example"><span class="header-section-number">3.1.4.1</span> Criando novas funções</h4>
<p>Vamos criar uma nova função que soma números:</p>
<pre class="language-julia"><code>function add_numbers(x, y)
    return x + y
end</code></pre>
<pre class="output"><code>add_numbers (generic function with 1 method)</code></pre>
<p>Agora, podemos usar nossa função <code>add_numbers</code>:</p>
<pre class="language-julia"><code>add_numbers(17, 29)</code></pre>
<pre class="output"><code>46</code></pre>
<p>E ela também funciona com números reais (também chamados em programação de números de ponto-flutuante ou, de forma mais curta, com o jargão “floats”):</p>
<pre class="language-julia"><code>add_numbers(3.14, 2.72)</code></pre>
<pre class="output"><code>5.86</code></pre>
<p>Além disso, podemos definir comportamentos especializados para nossa função, por meio da especificação de declarações de tipo. Suponha que queremos ter uma função <code>round_number</code> que se comporta de maneira diferente se seu argumento for um <code>Float64</code> ou <code>Int64</code>:</p>
<pre class="language-julia"><code>function round_number(x::Float64)
    return round(x)
end

function round_number(x::Int64)
    return x
end</code></pre>
<pre class="output"><code>round_number (generic function with 2 methods)</code></pre>
<p>Podemos ver que ela é uma função com múltiplos métodos:</p>
<pre class="language-julia"><code>methods(round_number)</code></pre>
<pre class="output"><code>round_number(x::Float64) in Main at none:1</code></pre>
<pre class="output"><code>round_number(x::Int64) in Main at none:5</code></pre>
<p>Mas há um problema: o que acontece se quisermos arredondar um float de 32 bits, <code>Float32</code>? Ou um inteiro de 8 bits, <code>Int8</code>?</p>
<p>Se você quiser que algo funcione em todos os tipos de float e inteiros, você pode usar um <strong>tipo abstrato</strong> na assinatura de tipo, como <code>AbstractFloat</code> ou <code>Integer</code>:</p>
<pre class="language-julia"><code>function round_number(x::AbstractFloat)
    return round(x)
end</code></pre>
<pre class="output"><code>round_number (generic function with 3 methods)</code></pre>
<p>Agora, funcionará da forma esperada com qualquer tipo de float:</p>
<pre class="language-julia"><code>x_32 = Float32(1.1)
round_number(x_32)</code></pre>
<pre class="output"><code>1.0</code></pre>
<blockquote>
<p><strong><em>OBSERVAÇÃO:</em></strong> Podemos inspecionar tipos com as funções <code>supertypes</code> e <code>subtypes</code>.</p>
</blockquote>
<p>Vamos voltar ao nosso <code>struct</code> <code>Language</code> que definimos anteriormente. Será um exemplo de despacho múltiplo. Vamos estender a função <code>Base.show</code> que imprime a saída de tipos instanciados e de <code>struct</code>.</p>
<p>Por padrão, uma <code>struct</code> tem um output básico, que você pôde observar do caso do <code>python</code>. Podemos definir um novo método <code>Base.show</code> para nosso tipo <code>Language</code>, assim temos uma boa impressão para nossas instâncias de linguagens de programação. Queremos comunicar claramente os nomes, títulos e idades em anos das linguagens de programação. A função <code>Base.show</code> aceita como argumentos um tipo <code>IO</code> chamado <code>io</code> seguido pelo tipo para o qual você deseja definir o comportamento personalizado:</p>
<pre class="language-julia"><code>Base.show(io::IO, l::Language) = print(
    io, l.name, &quot; &quot;,
    2021 - l.year_of_birth, &quot;, years old, &quot;,
    &quot;has the following titles: &quot;, l.title
)</code></pre>
<p>Agora, vamos ver como o output de <code>python</code> será:</p>
<pre class="language-julia"><code>python</code></pre>
<pre class="output"><code>Python 30, years old, has the following titles: Letargicus</code></pre>
<h4 data-number="3.1.4.2" id="sec:function_multiple"><span class="header-section-number">3.1.4.2</span> Múltiplos Valores de Retorno</h4>
<p>Uma função também pode retornar dois ou mais valores. Veja a nova função <code>add_multiply</code> abaixo:</p>
<pre class="language-julia"><code>function add_multiply(x, y)
    addition = x + y
    multiplication = x * y
    return addition, multiplication
end</code></pre>
<pre class="output"><code>add_multiply (generic function with 1 method)</code></pre>
<p>Nesse caso, podemos fazer duas coisas:</p>
<ol type="1">
<li><p>Podemos, analogamente aos valores de retorno, definir duas variáveis para conter os valores de retorno da função, uma para cada valor de retorno:</p>
<pre class="language-julia"><code>return_1, return_2 = add_multiply(1, 2)
return_2</code></pre>
<pre class="output"><code>2</code></pre></li>
<li><p>Ou podemos definir apenas uma variável para manter os valores de retorno da função e acessá-los com <code>first</code> ou <code>last</code>:</p>
<pre class="language-julia"><code>all_returns = add_multiply(1, 2)
last(all_returns)</code></pre>
<pre class="output"><code>2</code></pre></li>
</ol>
<h4 data-number="3.1.4.3" id="sec:function_keyword_arguments"><span class="header-section-number">3.1.4.3</span> Argumentos de Palavra-Chave</h4>
<p>Algumas funções podem aceitar argumentos de palavra-chave ao invés de argumentos posicionais. Esses argumentos são como argumentos comuns, exceto pelo fato de serem definidos após os argumentos de função regulares e separados por um ponto e vírgula <code>;</code>. Por exemplo, vamos definir uma função <code>logarithm</code> que por padrão usa base <span class="math inline">\(e\)</span> (2.718281828459045) como um argumento de palavra-chave. Perceba que aqui estamos usando o tipo abstrato <code>Real</code> para que possamos cobrir todos os tipos derivados de <code>Integer</code> e <code>AbstractFloat</code>, dado que ambos são subtipos de <code>Real</code>:</p>
<pre class="language-julia"><code>AbstractFloat &lt;: Real &amp;&amp; Integer &lt;: Real</code></pre>
<pre class="output"><code>true</code></pre>
<pre class="language-julia"><code>function logarithm(x::Real; base::Real=2.7182818284590)
    return log(base, x)
end</code></pre>
<pre class="output"><code>logarithm (generic function with 1 method)</code></pre>
<p>Funciona sem especificar o argumento <code>base</code> já que fornecemos um <strong>valor de argumento padrão</strong> na declaração da função:</p>
<pre class="language-julia"><code>logarithm(10)</code></pre>
<pre class="output"><code>2.3025850929940845</code></pre>
<p>E também com o argumento de palavra-chave <code>base</code> diferente de seu valor padrão:</p>
<pre class="language-julia"><code>logarithm(10; base=2)</code></pre>
<pre class="output"><code>3.3219280948873626</code></pre>
<h4 data-number="3.1.4.4" id="sec:function_anonymous"><span class="header-section-number">3.1.4.4</span> Funções Anônimas</h4>
<p>Muitas vezes não nos importamos com o nome da função e queremos criar uma rapidamente. O que precisamos é das <strong>funções anônimas</strong>. Elas são muito usadas no fluxo de trabalho de ciência de dados em Julia. Por exemplo, quando usamos <code>DataFrames.jl</code> (Section <a href="/pt/dataframes#sec:dataframes">4</a>) ou <code>Makie.jl</code> (Section <a href="/pt/DataVisualizationMakie#sec:DataVisualizationMakie">5</a>), às vezes precisamos de uma função temporária para filtrar dados ou formatar os rótulos de um gráfico. É aí que usamos as funções anônimas. Elas são especialmente úteis quando não queremos criar uma função e uma instrução simples seria o suficiente.</p>
<p>A sintaxe é simples. Nós usamos o operador <code>-&gt;</code>. À esquerda do <code>-&gt;</code> definimos o nome do parâmetro. E à direita do <code>-&gt;</code> definimos quais operações queremos realizar no parâmetro que definimos à esquerda de <code>-&gt;</code>. Segue um exemplo. Suponha que queremos desfazer a transformação de log usando uma exponenciação:</p>
<pre class="language-julia"><code>map(x -&gt; 2.7182818284590^x, logarithm(2))</code></pre>
<pre class="output"><code>2.0</code></pre>
<p>Aqui, estamos usando a função <code>map</code> para mapear convenientemente a função anônima (primeiro argumento) para <code>logarithm(2)</code> (segundo argumento). Como resultado, obtemos o mesmo número, porque o logaritmo e a exponenciação são inversos (pelo menos na base que escolhemos – 2.7182818284590)</p>
<h3 data-number="3.1.5" id="sec:conditionals"><span class="header-section-number">3.1.5</span> Condicional If-Else-Elseif</h3>
<p>Na maioria das linguagens de programação, o usuário tem permissão para controlar o fluxo de execução do computador. Dependendo da situação, queremos que o computador faça uma coisa ou outra. Em Julia, podemos controlar o fluxo de execução com as palavras-chave <code>if</code>, <code>elseif</code> e <code>else</code>. Estas são conhecidas como declarações condicionais.</p>
<p>A palavra-chave <code>if</code> comanda Julia a avaliar uma expressão e, dependendo se ela é verdadeira (<code>true</code>) ou falsa (<code>false</code>), a executar certas partes do código. Podemos combinar várias condições <code>if</code> com a palavra-chave <code>elseif</code> para um fluxo de controle complexo. Assim, podemos definir uma parte alternativa a ser executada se qualquer coisa dentro de <code>if</code> ou<code>elseif</code> for avaliada como <code>true</code>. Esse é o propósito da palavra-chave <code>else</code>. Finalmente, como em todos os operadores de palavra-chave que vimos anteriormente, devemos informar a Julia quando a declaração condicional for concluída com a palavra-chave <code>end</code>.</p>
<p>Aqui, temos um exemplo com todas as palavras-chave <code>if</code>-<code>elseif</code>-<code>else</code>:</p>
<pre class="language-julia"><code>a = 1
b = 2

if a &lt; b
    &quot;a is less than b&quot;
elseif a &gt; b
    &quot;a is greater than b&quot;
else
    &quot;a is equal to b&quot;
end</code></pre>
<pre class="output"><code>a is less than b</code></pre>
<p>Podemos até envelopar isso em uma função chamada <code>compare</code>:</p>
<pre class="language-julia"><code>function compare(a, b)
    if a &lt; b
        &quot;a is less than b&quot;
    elseif a &gt; b
        &quot;a is greater than b&quot;
    else
        &quot;a is equal to b&quot;
    end
end

compare(3.14, 3.14)</code></pre>
<p>a is equal to b</p>
<h3 data-number="3.1.6" id="sec:for"><span class="header-section-number">3.1.6</span> Laço For</h3>
<p>O clássico laço for em Julia segue uma sintaxe semelhante à das declarações condicionais. Você começa com a palavra-chave, nessa caso <code>for</code>. Em seguida, você especifica o que Julia deve iterar sobre (ou, no jargão, “loopar”), p. ex., uma sequência. Além disso, como em tudo mais, você deve terminar com a palavra-chave <code>end</code>.</p>
<p>Então, para fazer Julia imprimir todos os números de 1 a 10, você pode usar o seguinte laço for:</p>
<pre class="language-julia"><code>for i in 1:10
    println(i)
end</code></pre>
<h3 data-number="3.1.7" id="sec:while"><span class="header-section-number">3.1.7</span> Laço While</h3>
<p>O laço while é uma mistura das declarações condicionais anteriores com os laços for. Aqui, o laço é executado toda vez que a condição é avaliada como <code>true</code>. A sintaxe segue a mesma forma da anterior. Começamos com a palavra-chave <code>while</code>, seguido por uma declaração que é avaliada em <code>true</code> ou <code>false</code>. Como de costume, devemos terminar com a palavra-chave <code>end</code>.</p>
<p>Segue um exemplo:</p>
<pre class="language-julia"><code>n = 0

while n &lt; 3
    global n += 1
end

n</code></pre>
<pre class="output"><code>3</code></pre>
<p>Como pode ver, devemos usar a palavra-chave <code>global</code>. Isso se deve ao <strong>escopo de variável</strong>. Variáveis definidas dentro das declarações condicionais, laços e funções existem apenas dentro delas. Isso é conhecido como o <em>escopo</em> da variável. Aqui, precisamos avisar Julia que o <code>n</code> dentro do laço <code>while</code> está no escopo global por meio do uso da palavra-chave <code>global</code>.</p>
<p>Por fim, também usamos o operador <code>+=</code> que é uma boa abreviatura para <code>n = n + 1</code>.</p>


<div class="bottom-nav">
    <p id="nav-prev" style="text-align: left;">
        <a class="menu-level-1" href="/pt/julia_basics"><b>3</b> Básico de Julia</a> <kbd>←</kbd>
        <span id="nav-next" style="float: right;">
            <kbd>→</kbd> <a class="menu-level-2" href="/pt/data_structures"><b>3.2</b> Estruturas Nativas de Da..</a>
        </span>
    </p>
</div>


<div class="license">
    <br/>
  <br/>
  <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
    Jose Storopoli, Rik Huijzer, Lazaro Alonso
</div>
</div>
</div>
</body>
</html>