<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Jose Storopoli" />
  <meta name="author" content="Rik Huijzer" />
  <meta name="author" content="Lazaro Alonso" />
  <title>Language Syntax - Julia Data Science</title>
  <link rel="shortcut icon" type="image/png" href="/JuliaDataScience/favicon.png"/>
  <link rel="stylesheet" href="/JuliaDataScience/style.css"/>
    <script src="/JuliaDataScience/mousetrap.min.js"></script>
    <style>
  @font-face {
    font-family: JuliaMono-Regular;
    src: url("/JuliaDataScience/JuliaMono-Regular.woff2");
  }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <link rel="stylesheet" href="/JuliaDataScience/github.min.css">
<script src="/JuliaDataScience/highlight.min.js"></script>
<script src="/JuliaDataScience/julia.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', (event) => {
    document.querySelectorAll('pre').forEach((el) => {
        if (!el.classList.contains('output')) {
            hljs.highlightElement(el);
        }
    });
});
</script>
 
</head>
<body>
<script>
function click_next() {
  var next = document.getElementById('nav-next');
  next.firstElementChild.nextElementSibling.click();
}
function click_prev() {
  var prev = document.getElementById('nav-prev');
  prev.firstElementChild.click();
}
Mousetrap.bind('right', click_next);
Mousetrap.bind('h', click_prev);
Mousetrap.bind('left', click_prev);
Mousetrap.bind('l', click_next);
</script>

<div class="books-container">
<aside class="books-menu">
<input type="checkbox" id="menu">
<label for="menu">☰</label>
<div class="books-title">
<a href="/JuliaDataScience/">Julia Data Science</a>
</div><br />
<span class="books-subtitle">

</span>
<div class="books-menu-content">
<li><a class="menu-level-1" href="/JuliaDataScience/preface"><b>1</b> Preface</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/why_data_science"><b>1.1</b> What is Data Science?</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/engineering"><b>1.2</b> Software Engineering</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/acknowledgements"><b>1.3</b> Acknowledgements</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/why_julia"><b>2</b> Why Julia?</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/non-programmers"><b>2.1</b> For Non-Programmers</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/programmers"><b>2.2</b> For Programmers</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/julia_accomplish"><b>2.3</b> What Julia Aims to Accom..</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/julia_wild"><b>2.4</b> Julia in the Wild</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/julia_basics"><b>3</b> Julia Basics</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/ide"><b>3.1</b> Development Environments</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/syntax"><b>3.2</b> Language Syntax</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/data_structures"><b>3.3</b> Native Data Structures</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/filesystem"><b>3.4</b> Filesystem</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/standardlibrary"><b>3.5</b> Julia Standard Library</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/dataframes"><b>4</b> DataFrames.jl</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/load_save"><b>4.1</b> Load and Save Files</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/index-and-summarize"><b>4.2</b> Index and Summarize</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/filter_subset"><b>4.3</b> Filter and Subset</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/select"><b>4.4</b> Select</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/types"><b>4.5</b> Types and Categorical Da..</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/join"><b>4.6</b> Join</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/transform"><b>4.7</b> Variable Transformations</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/groupby_combine"><b>4.8</b> Groupby and Combine</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/missing"><b>4.9</b> Missing Data</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/df_performance"><b>4.10</b> Performance</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/dataframesmeta"><b>5</b> DataFramesMeta.jl</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/dataframesmeta_macros"><b>5.1</b> Macros</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/dataframesmeta_select"><b>5.2</b> Column Selection</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/dataframesmeta_transform"><b>5.3</b> Column Transformation</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/dataframesmeta_subset"><b>5.4</b> Row Selection</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/dataframesmeta_orderby"><b>5.5</b> Row Sorting</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/dataframesmeta_combine"><b>5.6</b> Data Summaries</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/dataframesmeta_chain"><b>5.7</b> Piping Operations</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/DataVisualizationMakie"><b>6</b> Data Visualization with Ma..</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/cairomakie"><b>6.1</b> CairoMakie.jl</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/datavisMakie_attributes"><b>6.2</b> Attributes</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/datavisMakie_create_Figure"><b>6.3</b> Create Plot Figure</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/makie_cheat_sheets"><b>6.4</b> Cheat Sheets</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/themes"><b>6.5</b> Themes</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/using-latexstrings.jl"><b>6.6</b> Using LaTeXStrings.jl</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/makie_colors"><b>6.7</b> Colors and Colormaps</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/makie_layouts"><b>6.8</b> Layouts</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/glmakie"><b>6.9</b> GLMakie.jl</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/recipe_df"><b>6.10</b> A Makie recipe for a Da..</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/aog"><b>7</b> Data Visualization with Al..</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/aog_layers"><b>7.1</b> Layers</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/aog_layouts"><b>7.2</b> Layouts</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/aog_stats"><b>7.3</b> Statistical Visualizatio..</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/aog_custom"><b>7.4</b> Plot Customizations</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/aog_makie"><b>7.5</b> Makie.jl and AlgebraOfGr..</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/appendix"><b>8</b> Appendix</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/appendix_pkg"><b>8.1</b> Packages Versions</a></li>
<li><a class="menu-level-2" href="/JuliaDataScience/notation"><b>8.2</b> Notation</a></li>
<li><a class="menu-level-1" href="/JuliaDataScience/references"><b></b> References</a></li>
</div>
</aside>

<div class="books-content">
<h2 data-number="3.2" id="sec:syntax"><span class="header-section-number">3.2</span> Language Syntax</h2>
<p>Julia is a <strong>dynamic-typed language</strong> with a just-in-time compiler. This means that you don’t need to compile your program before you run it, like you would do in C++ or FORTRAN. Instead, Julia will take your code, guess types where necessary, and compile parts of code just before running it. Also, you don’t need to explicitly specify each type. Julia will guess types for you on the go.</p>
<p>The main differences between Julia and other dynamic languages such as R and Python are the following. First, Julia <strong>allows the user to specify type declarations</strong>. You already saw some types declarations in <em>Why Julia?</em> (Section <a href="/JuliaDataScience/why_julia#sec:why_julia">2</a>): they are those double colons <code>::</code> that sometimes come after variables. However, if you don’t want to specify the type of your variables or functions, Julia will gladly infer (guess) them for you.</p>
<p>Second, Julia allows users to define function behavior across many combinations of argument types via multiple dispatch. We also covered multiple dispatch in Section <a href="/JuliaDataScience/julia_accomplish#sec:julia_accomplish">2.3</a>. We defined a different type behavior by defining new function signatures for argument types while using the same function name.</p>
<h3 data-number="3.2.1" id="sec:variable"><span class="header-section-number">3.2.1</span> Variables</h3>
<p>Variables are values that you tell the computer to store with a specific name, so that you can later recover or change its value. Julia has several types of variables but, in data science, we mostly use:</p>
<ul>
<li>Integers: <code>Int64</code></li>
<li>Real Numbers: <code>Float64</code></li>
<li>Boolean: <code>Bool</code></li>
<li>Strings: <code>String</code></li>
</ul>
<p>Integers and real numbers are stored by using 64 bits by default, that’s why they have the <code>64</code> suffix in the name of the type. If you need more or less precision, there are <code>Int8</code> or <code>Int128</code> types, for example, where higher means more precision. Most of the time, this won’t be an issue so you can just stick to the defaults.</p>
<p>We create new variables by writing the variable name on the left and its value in the right, and in the middle we use the <code>=</code> assignment operator. For example:</p>
<pre class="language-julia"><code>name = &quot;Julia&quot;
age = 9</code></pre>
<pre class="output"><code>
9
</code></pre>
<p>Note that the return output of the last statement (<code>age</code>) was printed to the console. Here, we are defining two new variables: <code>name</code> and <code>age</code>. We can recover their values by typing the names given in the assignment:</p>
<pre class="language-julia"><code>name</code></pre>
<pre class="output"><code>
Julia
</code></pre>
<p>If you want to define new values for an existing variable, you can repeat the steps in the assignment. Note that Julia will now override the previous value with the new one. Supposed, Julia’s birthday has passed and now it has turned 10:</p>
<pre class="language-julia"><code>age = 10</code></pre>
<pre class="output"><code>
10
</code></pre>
<p>We can do the same with its <code>name</code>. Suppose that Julia has earned some titles due to its blazing speed. We would change the variable <code>name</code> to the new value:</p>
<pre class="language-julia"><code>name = &quot;Julia Rapidus&quot;</code></pre>
<pre class="output"><code>
Julia Rapidus
</code></pre>
<p>We can also do operations on variables such as addition or division. Let’s see how old Julia is, in months, by multiplying <code>age</code> by 12:</p>
<pre class="language-julia"><code>12 * age</code></pre>
<pre class="output"><code>
120
</code></pre>
<p>We can inspect the types of variables by using the <code>typeof</code> function:</p>
<pre class="language-julia"><code>typeof(age)</code></pre>
<pre class="output"><code>Int64</code></pre>
<p>The next question then becomes: “What else can I do with integers?” There is a nice handy function <code>methodswith</code> that spits out every function available, along with its signature, for a certain type. Here, we will restrict the output to the first 5 rows:</p>
<pre class="language-julia"><code>first(methodswith(Int64), 5)</code></pre>
<pre class="output"><code>[1] AbstractFloat(x::Int64) @ Base float.jl:348
[2] Float16(x::Int64) @ Base float.jl:239
[3] Float32(x::Int64) @ Base float.jl:239
[4] Float64(x::Int64) @ Base float.jl:239
[5] Int64(x::Union{Bool, Int32, Int64, UInt16, UInt32, UInt64, UInt8, Int128, Int16, Int8, UInt128}) @ Core boot.jl:892</code></pre>
<h3 data-number="3.2.2" id="sec:struct"><span class="header-section-number">3.2.2</span> User-defined Types</h3>
<p>Having variables around without any sort of hierarchy or relationships is not ideal. In Julia, we can define that kind of structured data with a <code>struct</code> (also known as a composite type). Inside each <code>struct</code>, you can specify a set of fields. They differ from the primitive types (e.g. integer and floats) that are by default defined already inside the core of Julia language. Since most <code>struct</code>s are user-defined, they are known as user-defined types.</p>
<p>For example, let’s create a <code>struct</code> to represent scientific open source programming languages. We’ll also define a set of fields along with the corresponding types inside the <code>struct</code>:</p>
<pre class="language-julia"><code>struct Language
    name::String
    title::String
    year_of_birth::Int64
    fast::Bool
end</code></pre>
<p>To inspect the field names you can use the <code>fieldnames</code> and pass the desired <code>struct</code> as an argument:</p>
<pre class="language-julia"><code>fieldnames(Language)</code></pre>
<pre class="output"><code>(:name, :title, :year_of_birth, :fast)</code></pre>
<p>To use <code>struct</code>s, we must instantiate individual instances (or “objects”), each with its own specific values for the fields defined inside the <code>struct</code>. Let’s instantiate two instances, one for Julia and one for Python:</p>
<pre class="language-julia"><code>julia = Language(&quot;Julia&quot;, &quot;Rapidus&quot;, 2012, true)
python = Language(&quot;Python&quot;, &quot;Letargicus&quot;, 1991, false)</code></pre>
<pre class="output"><code>Language(&quot;Python&quot;, &quot;Letargicus&quot;, 1991, false)</code></pre>
<p>One thing to note with <code>struct</code>s is that we can’t change their values once they are instantiated. We can solve this with a <code>mutable struct</code>. Also, note that mutable objects will, generally, be slower and more error prone. Whenever possible, make everything <em>immutable</em>. Let’s create a <code>mutable struct</code>.</p>
<pre class="language-julia"><code>mutable struct MutableLanguage
    name::String
    title::String
    year_of_birth::Int64
    fast::Bool
end

julia_mutable = MutableLanguage(&quot;Julia&quot;, &quot;Rapidus&quot;, 2012, true)</code></pre>
<pre class="output"><code>MutableLanguage(&quot;Julia&quot;, &quot;Rapidus&quot;, 2012, true)</code></pre>
<p>Suppose that we want to change <code>julia_mutable</code>’s title. Now, we can do this since <code>julia_mutable</code> is an instantiated <code>mutable struct</code>:</p>
<pre class="language-julia"><code>julia_mutable.title = &quot;Python Obliteratus&quot;

julia_mutable</code></pre>
<pre class="output"><code>MutableLanguage(&quot;Julia&quot;, &quot;Python Obliteratus&quot;, 2012, true)</code></pre>
<h3 data-number="3.2.3" id="boolean-operators-and-numeric-comparisons"><span class="header-section-number">3.2.3</span> Boolean Operators and Numeric Comparisons</h3>
<p>Now that we’ve covered types, we can move to boolean operators and numeric comparison.</p>
<p>We have three boolean operators in Julia:</p>
<ul>
<li><code>!</code>: <strong>NOT</strong></li>
<li><code>&amp;&amp;</code>: <strong>AND</strong></li>
<li><code>||</code>: <strong>OR</strong></li>
</ul>
<p>Here are a few examples with some of them:</p>
<pre class="language-julia"><code>!true</code></pre>
<pre class="output"><code>
false
</code></pre>
<pre class="language-julia"><code>(false &amp;&amp; true) || (!false)</code></pre>
<pre class="output"><code>
true
</code></pre>
<pre class="language-julia"><code>(6 isa Int64) &amp;&amp; (6 isa Real)</code></pre>
<pre class="output"><code>
true
</code></pre>
<p>Regarding numeric comparison, Julia has three major types of comparisons:</p>
<ol type="1">
<li><strong>Equality</strong>: either something is <em>equal</em> or <em>not equal</em> another
<ul>
<li>== “equal”</li>
<li>!= or ≠ “not equal”</li>
</ul></li>
<li><strong>Less than</strong>: either something is <em>less than</em> or <em>less than or equal to</em>
<ul>
<li>&lt; “less than”</li>
<li>&lt;= or ≤ “less than or equal to”</li>
</ul></li>
<li><strong>Greater than</strong>: either something is <em>greater than</em> or <em>greater than or equal to</em>
<ul>
<li>&gt; “greater than”</li>
<li>&gt;= or ≥ “greater than or equal to”</li>
</ul></li>
</ol>
<p>Here are some examples:</p>
<pre class="language-julia"><code>1 == 1</code></pre>
<pre class="output"><code>
true
</code></pre>
<pre class="language-julia"><code>1 &gt;= 10</code></pre>
<pre class="output"><code>
false
</code></pre>
<p>It evens works between different types:</p>
<pre class="language-julia"><code>1 == 1.0</code></pre>
<pre class="output"><code>
true
</code></pre>
<p>We can also mix and match boolean operators with numeric comparisons:</p>
<pre class="language-julia"><code>(1 != 10) || (3.14 &lt;= 2.71)</code></pre>
<pre class="output"><code>
true
</code></pre>
<h3 data-number="3.2.4" id="sec:function"><span class="header-section-number">3.2.4</span> Functions</h3>
<p>Now that we already know how to define variables and custom types as <code>struct</code>s, let’s turn our attention to <strong>functions</strong>. In Julia, a function <strong>maps argument’s values to one or more return values</strong>. The basic syntax goes like this:</p>
<pre class="julia"><code>function function_name(arg1, arg2)
    result = stuff with the arg1 and arg2
    return result
end</code></pre>
<p>The function declaration begins with the keyword <code>function</code> followed by the function name. Then, inside parentheses <code>()</code>, we define the arguments separated by a comma <code>,</code>. Inside the function, we specify what we want Julia to do with the parameters that we supplied. All variables that we define inside a function are deleted after the function returns. This is nice because it is like an automatic cleanup. After all the operations in the function body are finished, we instruct Julia to return the final result with the <code>return</code> statement. Finally, we let Julia know that the function definition is finished with the <code>end</code> keyword.</p>
<p>There is also the compact <strong>assignment form</strong>:</p>
<pre class="julia"><code>f_name(arg1, arg2) = stuff with the arg1 and arg2</code></pre>
<p>It is the <strong>same function</strong> as before but with a different, more compact, form. As a rule of thumb, when your code can fit easily on one line of up to 92 characters, then the compact form is suitable. Otherwise, just use the longer form with the <code>function</code> keyword. Let’s dive into some examples.</p>
<h4 data-number="3.2.4.1" id="sec:function_example"><span class="header-section-number">3.2.4.1</span> Creating new Functions</h4>
<p>Let’s create a new function that adds numbers together:</p>
<pre class="language-julia"><code>function add_numbers(x, y)
    return x + y
end</code></pre>
<pre class="output"><code>add_numbers (generic function with 1 method)</code></pre>
<p>Now, we can use our <code>add_numbers</code> function:</p>
<pre class="language-julia"><code>add_numbers(17, 29)</code></pre>
<pre class="output"><code>
46
</code></pre>
<p>And it works also with floats:</p>
<pre class="language-julia"><code>add_numbers(3.14, 2.72)</code></pre>
<pre class="output"><code>
5.86
</code></pre>
<p>Also, we can define custom behavior by specifying type declarations. Suppose that we want to have a <code>round_number</code> function that behaves differently if its argument is either a <code>Float64</code> or <code>Int64</code>:</p>
<pre class="language-julia"><code>function round_number(x::Float64)
    return round(x)
end

function round_number(x::Int64)
    return x
end</code></pre>
<pre class="output"><code>round_number (generic function with 2 methods)</code></pre>
<p>We can see that it is a function with multiple methods:</p>
<pre class="language-julia"><code>methods(round_number)</code></pre>
<pre class="output"><code>round_number(x::Int64)
     @ Main none:5</code></pre>
<pre class="output"><code>round_number(x::Float64)
     @ Main none:1</code></pre>
<p>There is one issue: what happens if we want to round a 32-bit float <code>Float32</code>? Or a 8-bit integer <code>Int8</code>?</p>
<p>If you want something to function on all float and integer types, you can use an <strong>abstract type</strong> as the type signature, such as <code>AbstractFloat</code> or <code>Integer</code>:</p>
<pre class="language-julia"><code>function round_number(x::AbstractFloat)
    return round(x)
end</code></pre>
<pre class="output"><code>round_number (generic function with 3 methods)</code></pre>
<p>Now, it works as expected with any float type:</p>
<pre class="language-julia"><code>x_32 = Float32(1.1)
round_number(x_32)</code></pre>
<pre class="output"><code>1.0f0</code></pre>
<blockquote>
<p><strong><em>NOTE:</em></strong> We can inspect types with the <code>supertypes</code> and <code>subtypes</code> functions.</p>
</blockquote>
<p>Let’s go back to our <code>Language</code> <code>struct</code> that we defined above. This is an example of multiple dispatch. We will extend the <code>Base.show</code> function that prints the output of instantiated types and <code>struct</code>s.</p>
<p>By default, a <code>struct</code> has a basic output, which you saw above in the <code>python</code> case. We can define a new <code>Base.show</code> method to our <code>Language</code> type, so that we have some nice printing for our programming languages instances. We want to clearly communicate programming languages’ names, titles, and ages in years. The function <code>Base.show</code> accepts as arguments a <code>IO</code> type named <code>io</code> followed by the type you want to define custom behavior:</p>
<pre class="language-julia"><code>Base.show(io::IO, l::Language) = print(
    io, l.name, &quot;, &quot;,
    2021 - l.year_of_birth, &quot; years old, &quot;,
    &quot;has the following titles: &quot;, l.title
)</code></pre>
<p>Now, let’s see how <code>python</code> will output:</p>
<pre class="language-julia"><code>python</code></pre>
<pre class="output"><code>Python, 30 years old, has the following titles: Letargicus</code></pre>
<h4 data-number="3.2.4.2" id="sec:function_multiple"><span class="header-section-number">3.2.4.2</span> Multiple Return Values</h4>
<p>A function can, also, return two or more values. See the new function <code>add_multiply</code> below:</p>
<pre class="language-julia"><code>function add_multiply(x, y)
    addition = x + y
    multiplication = x * y
    return addition, multiplication
end</code></pre>
<pre class="output"><code>add_multiply (generic function with 1 method)</code></pre>
<p>In that case, we can do two things:</p>
<ol type="1">
<li><p>We can, analogously as the return values, define two variables to hold the function return values, one for each return value:</p>
<pre class="language-julia"><code>return_1, return_2 = add_multiply(1, 2)
return_2</code></pre>
<pre class="output"><code>
2
</code></pre></li>
<li><p>Or we can define just one variable to hold the function’s return values and access them with either <code>first</code> or <code>last</code>:</p>
<pre class="language-julia"><code>all_returns = add_multiply(1, 2)
last(all_returns)</code></pre>
<pre class="output"><code>
2
</code></pre></li>
</ol>
<h4 data-number="3.2.4.3" id="sec:function_keyword_arguments"><span class="header-section-number">3.2.4.3</span> Keyword Arguments</h4>
<p>Some functions can accept keyword arguments instead of positional arguments. These arguments are just like regular arguments, except that they are defined after the regular function’s arguments and separated by a semicolon <code>;</code>. For example, let’s define a <code>logarithm</code> function that by default uses base <span class="math inline">\(e\)</span> (2.718281828459045) as a keyword argument. Note that, here, we are using the abstract type <code>Real</code> so that we cover all types derived from <code>Integer</code> and <code>AbstractFloat</code>, being both themselves subtypes of <code>Real</code>:</p>
<pre class="language-julia"><code>AbstractFloat &lt;: Real &amp;&amp; Integer &lt;: Real</code></pre>
<pre class="output"><code>
true
</code></pre>
<pre class="language-julia"><code>function logarithm(x::Real; base::Real=2.7182818284590)
    return log(base, x)
end</code></pre>
<pre class="output"><code>logarithm (generic function with 1 method)</code></pre>
<p>It works without specifying the <code>base</code> argument as we supplied a <strong>default argument value</strong> in the function declaration:</p>
<pre class="language-julia"><code>logarithm(10)</code></pre>
<pre class="output"><code>
2.3025850929940845
</code></pre>
<p>And also with the keyword argument <code>base</code> different from its default value:</p>
<pre class="language-julia"><code>logarithm(10; base=2)</code></pre>
<pre class="output"><code>
3.3219280948873626
</code></pre>
<h4 data-number="3.2.4.4" id="sec:function_anonymous"><span class="header-section-number">3.2.4.4</span> Anonymous Functions</h4>
<p>Often we don’t care about the name of the function and want to quickly make one. What we need are <strong>anonymous functions</strong>. They are used a lot in Julia’s data science workflow. For example, when using <code>DataFrames.jl</code> (Section <a href="/JuliaDataScience/dataframes#sec:dataframes">4</a>) or <code>Makie.jl</code> (Section <a href="/JuliaDataScience/DataVisualizationMakie#sec:DataVisualizationMakie">6</a>), sometimes we need a temporary function to filter data or format plot labels. That’s when we use anonymous functions. They are especially useful when we don’t want to create a function, and a simple in-place statement would be enough.</p>
<p>The syntax is simple. We use the <code>-&gt;</code> operator. On the left of <code>-&gt;</code> we define the parameter name. And on the right of <code>-&gt;</code> we define what operations we want to perform on the parameter that we defined on the left of <code>-&gt;</code>. Here is an example. Suppose that we want to undo the log transformation by using an exponentiation:</p>
<pre class="language-julia"><code>map(x -&gt; 2.7182818284590^x, logarithm(2))</code></pre>
<pre class="output"><code>
2.0
</code></pre>
<p>Here, we are using the <code>map</code> function to conveniently map the anonymous function (first argument) to <code>logarithm(2)</code> (the second argument). As a result, we get back the same number, because logarithm and exponentiation are inverse (at least in the base that we’ve chosen – 2.7182818284590)</p>
<h3 data-number="3.2.5" id="sec:conditionals"><span class="header-section-number">3.2.5</span> Conditional If-Else-Elseif</h3>
<p>In most programming languages, the user is allowed to control the computer’s flow of execution. Depending on the situation, we want the computer to do one thing or another. In Julia we can control the flow of execution with <code>if</code>, <code>elseif</code>, and <code>else</code> keywords. These are known as conditional statements.</p>
<p>The <code>if</code> keyword prompts Julia to evaluate an expression and, depending on whether it’s <code>true</code> or <code>false</code>, execute certain portions of code. We can compound several <code>if</code> conditions with the <code>elseif</code> keyword for complex control flow. Finally, we can define an alternative portion to be executed if anything inside the <code>if</code> or <code>elseif</code>s is evaluated to <code>true</code>. This is the purpose of the <code>else</code> keyword. Finally, like all the previous keyword operators that we saw, we must tell Julia when the conditional statement is finished with the <code>end</code> keyword.</p>
<p>Here’s an example with all the <code>if</code>-<code>elseif</code>-<code>else</code> keywords:</p>
<pre class="language-julia"><code>a = 1
b = 2

if a &lt; b
    &quot;a is less than b&quot;
elseif a &gt; b
    &quot;a is greater than b&quot;
else
    &quot;a is equal to b&quot;
end</code></pre>
<pre class="output"><code>
a is less than b
</code></pre>
<p>We can even wrap this in a function called <code>compare</code>:</p>
<pre class="language-julia"><code>function compare(a, b)
    if a &lt; b
        &quot;a is less than b&quot;
    elseif a &gt; b
        &quot;a is greater than b&quot;
    else
        &quot;a is equal to b&quot;
    end
end

compare(3.14, 3.14)</code></pre>
<p>a is equal to b</p>
<h3 data-number="3.2.6" id="sec:for"><span class="header-section-number">3.2.6</span> For Loop</h3>
<p>The classical for loop in Julia follows a similar syntax as the conditional statements. You begin with a keyword, in this case <code>for</code>. Then, you specify what Julia should “loop” for, i.e., a sequence. Also, like everything else, you must finish with the <code>end</code> keyword.</p>
<p>So, to make Julia print every number from 1 to 10, you can use the following for loop:</p>
<pre class="language-julia"><code>for i in 1:10
    println(i)
end</code></pre>
<h3 data-number="3.2.7" id="sec:while"><span class="header-section-number">3.2.7</span> While Loop</h3>
<p>The while loop is a mix of the previous conditional statements and for loops. Here, the loop is executed every time the condition is <code>true</code>. The syntax follows the same form as the previous one. We begin with the keyword <code>while</code>, followed by a statement that evaluates to <code>true</code> or <code>false</code>. As usual, you must end with the <code>end</code> keyword.</p>
<p>Here’s an example:</p>
<pre class="language-julia"><code>n = 0

while n &lt; 3
    global n += 1
end

n</code></pre>
<pre class="output"><code>
3
</code></pre>
<p>As you can see, we have to use the <code>global</code> keyword. This is because of <strong>variable scope</strong>. Variables defined inside conditional statements, loops, and functions exist only inside them. This is known as the <em>scope</em> of the variable. Here, we had to tell Julia that the <code>n</code> inside <code>while</code> loop is in the global scope with the <code>global</code> keyword.</p>
<p>Finally, we also used the <code>+=</code> operator which is a nice shorthand for <code>n = n + 1</code>.</p>


<div class="bottom-nav">
    <p id="nav-prev" style="text-align: left;">
        <a class="menu-level-2" href="/JuliaDataScience/ide"><b>3.1</b> Development Environments</a> <kbd>←</kbd>
        <span id="nav-next" style="float: right;">
            <kbd>→</kbd> <a class="menu-level-2" href="/JuliaDataScience/data_structures"><b>3.3</b> Native Data Structures</a>
        </span>
    </p>
</div>


<div class="license">
    <br/>
  <br/>
  <span style="display: flex; justify-content: center;"> <a
      style="display: flex; align-items: center; border: 1.5px solid black; border-radius: 10px;"
      href="https://opencollective.com/juliadatascience" target="_blank"> <img src="/images/coffee.png" height="18px" style="margin: 5px; display:inline"> <span style="margin-left: 4px; color: black !important">Support this project</span> </a> </span> <br> <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
    Jose Storopoli, Rik Huijzer, Lazaro Alonso
</div>
</div>
</div>
</body>
</html>